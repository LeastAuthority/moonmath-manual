\chapter{Proof Systems }
Proofs are the evidence of correctness of the assertions, and people can verify the cor-rectness by reading the proof. However, we obtain much more than the correctness itself:After you read one proof of an assertion, you know not only the correctness, but also why itis correct. Is it possible to solely show the correctness of an assertion without revealing theknowledge of proofs? It turns out that it is indeed possible, and this is the topic of today’slecture: Zero Knowledge Systems.
% from http://resources.mpi-inf.mpg.de/departments/d1/teaching/ss14/gitcs/notes6.pdf

\section{Pairing Based Proof Systems}

\subsection{Quadratic Arithmetic Programs}
As shown by [Pinocchio] rank-1 constraint systems can be transformed into so called quadratic  arithmetic  programs  assuming $\F$.

taken from the pinocchio paper. For proving arithmetic circuit-sat.  Given a R1CS QAPs transform potential solution vectors into two polynomials $p$ and $t$, such that $p$ is divisible by $t$ if and only if the vector is a solution to the R1CS. 

They are major building blocks for \textbf{succinct} proofs, since with high probability, the divisibility check can be performed in a single point of those polynomials. So computationally expensive polynomial division check is reduced TO WHAT? (IN FIELDS THERE IS ALWAYS DIVISIBILITY) 
% https://courses.cs.ut.ee/MTAT.07.022/2013_fall/uploads/Main/alisa-report

\begin{definition}[Quadratic Arithmetic Program]
Assume we have a Galois field $\F$, three numbers $i,j,k$ as well as three $(i+j+1) \times k$ matrices $A$, $B$ and $C$  with coefficients in $\F$ that define the R1CS
$Ax \odot Bx = Cx $ for some statement $x=(1,i,w)$ and let $m_1,\ldots,m_k\in \F$ be arbitrary field elements. 

Then a \textbf{quadratic arithmetic program} of the R1CS is the following set of polynomials over $\F$
$$
QAP = \left\{t\in \F[x],\left\{a_h,b_h,c_h\in \F[x]\right\}_{h=1}^{i+j+1}\right\}
$$
where $t(x) := \Pi_{l=1}^k (x- m_l)$ is a polynomial f degree $k$, called the \textbf{target polynomial} of the QAP and $a_h(x)$, $b_h(x)$ as well as $c_h(x)$ are the unique degree $k-1$ polynomials that are defined by the equations
$$
\begin{array}{lllr}
a_h(m_l)=A_{h,l} & b_h(m_l)=B_{h,l} & c_h(m_l)=C_{h,l} & h= 1, \ldots , i+j+1, l=1,\ldots,k 
\end{array}
$$  
\end{definition}
The major point is that R1CS-sat can be reformulated into the divisibility of a polynomials defined by any QAP.
\begin{theorem}
Assume that an R1CS and an associated QAP as defined in XXX are given. Then the affine vector $y=(1,i,w)$ is a solution to the R1CS, if and only if the polynomial
$$
p(x) = \left(\sum y_h\cdot a_h(x)\right)\cdot \left(\sum y_h\cdot b_h(x)\right)  - \sum y_h\cdot c_h(x) 
$$
is divisible by the target polynomial $t$.
\end{theorem}

The polynomials $a_h$, $b_h$ and $c_h$ are uniquely defined by the equations in XXX. However to actually compute them we need some algorithm like the Langrange XXX from XXX.

\begin{example}[Generalized factorization snark]
In this example we want to transform the R1CS from example \ref{main_example_2_3} into an associated QAP.

We start by choosing an arbitrary field element for every constraint in the R1CS, since we have $2$ constraints we choose $m_{1}=5$ and $m_{2}=7$

With this choice we get the target polynomial $t(x)=(x-m_1)(x-m_2)= (x-5)(x-7)= (x+8)(x+6)= x^2 + x +9$.

Since our statement has structure $w=(1, in_1,in_2,in_3,m_1,out_1)$ we have to compute the following degree $1$ polynomials

$\{a_{c},a_{in_{1}},a_{in_{2}},a_{in_{3}},a_{mid_{1}},a_{out}\}$
$\{b_{c},b_{in_{1}},b_{in_{2}},b_{in_{3}},b_{mid_{1}},b_{out}\}$
$\{c_{c},c_{in_{1}},c_{in_{2}},c_{in_{3}},c_{mid_{1}},c_{out}\}$

\item Apply QAP rule XXX to the $a_{k\in I}$ polynomials gives
$$
\begin{array}{llllll}
a_{c}(5)=0, & a_{in_{1}}(5)=1, & a_{in_{2}}(5)=0, & a_{in_{3}}(5)=0, & a_{mid_{1}}(5)=0, & a_{out}(5)=0 \\
a_{c}(7)=0, & a_{in_{1}}(7)=0, & a_{in_{2}}(7)=0, & a_{in_{3}}(7)=0, & a_{mid_{1}}(7)=1, & a_{out}(7)=0\\
\\
b_{c}(5)=0, & b_{in_{1}}(5)=0, & b_{in_{2}}(5)=1, & b_{in_{3}}(5)=0, & b_{mid_{1}}(5)=0, & b_{out}(5)=0 \\
b_{c}(7)=0, & b_{in_{1}}(7)=0, & b_{in_{2}}(7)=0, & b_{in_{3}}(7)=1, & b_{mid_{1}}(7)=0, & b_{out}(7)=0\\
\\
c_{c}(5)=0, & c_{in_{1}}(5)=0, & c_{in_{2}}(5)=0, & c_{in_{3}}(5)=0, & c_{mid_{1}}(5)=1, & c_{out}(5)=0 \\
c_{c}(7)=0, & c_{in_{1}}(7)=0, & c_{in_{2}}(7)=0, & c_{in_{3}}(7)=0, & c_{mid_{1}}(7)=0, & c_{out}(7)=1
\end{array}
$$

Since our polynomials are of degree $1$ only we don't have to invoke Langrange method but can deduce the solutions right away. 

Polynomials are defined on the two values $5$ and $7$ here.
Linear Polynomial $f(x)=m\cdot x + b$ is fully determined by this. Derive the general equation:
\begin{itemize}                        
\item  $5m+b=f(5)$  and $7m+b=f(7)$  
\item  $b=f(5)-5m$ and  $b=f(7)-7m$   
\item  $b=f(5)+8m$ and  $b=f(7)+6m$  
\item  $f(5)+8m=f(7)+6m$              
\item  $8m-6m=f(7)-f(5)$               
\item  $2m=f(7)+ 12f(5)$              
\item  $7\cdot 2m=7(f(7)+12f(5))$              
\item  $m=7(f(7)+12f(5))$ 
\item             
\item  $b=f(5)+8m$                   
\item  $b=f(5)+8\cdot(7(f(7)+12f(5)))$
\item  $b=f(5)+4(f(7)+12f(5))$ 
\item  $b=f(5)+4f(7)+9f(5)$ 
\item  $b= 10f(5)+4f(7)$ 
\end{itemize}
Gives the general equation: $f(x)=7(f(7)+12f(5))x+10f(5)+4f(7)$

For $a_{in_1}$ the computation looks like this:
\begin{itemize}
\item $ a_{in_{1}}(x) = 7(a_{in_{1}}(7)+12a_{in_{1}}(5))x+ 
10a_{in_{1}}(5)+4a_{in_{1}}(7)=$
\item $7(0 + 12\cdot 1)x+ 
10\cdot 1 +4\cdot 0 =$
\item $7\cdot 12 x + 10=$
\item $6x+10$
\end{itemize}
\begin{itemize}
\item $ a_{mid_{1}}(x) = 7(a_{mid_{1}}(7)+12a_{mid_{1}}(5))x+ 
10a_{mid_{1}}(5)+4a_{mid_{1}}(7)=$
\item $7(1 + 12\cdot 0)x+ 10\cdot 0 +4\cdot 1=$
\item $7\cdot 1x +4=$
\item $7x+4 $
\end{itemize}


\begin{tabular}{|l|l|l|}\hline 
$a_{c}(x)=0 $ &$ b_{c}(x)=0   $ & $c_{c}(x)=0$ \tabularnewline\hline 
$a_{in_{1}}(x)=6x+10 $ &$ b_{in_{1}}(x)=0   $ & $c_{in_1}(x)=0$ \tabularnewline\hline 
$a_{in_{2}}(x)=0    $ &$ b_{in_{2}}(x)=6x+10$ & $c_{in_2}(x)=0$ \tabularnewline\hline 
$a_{in_{3}}(x)=0    $ &$ b_{in_{3}}(x)=7x+4$ & $c_{in_{3}}(x)=0$ \tabularnewline\hline 
$a_{mid_{1}}(x)=7x+4$ &$ b_{mid_{1}}(x)=0  $ & $c_{mid_{1}}(x)=6x+10$ \tabularnewline\hline 
$a_{out}(x)=0       $ &$ b_{out}(x)=0      $ & $c_{out}(x)=7x+4$ \tabularnewline\hline 
\end{tabular}
This gives the quadratic arithmetic program for our generalized factorization snark as
$$QAP=\{x^{2}+x+9,\{0,6x+10,0,0,7x+4,0\},\{0,0,6x+10,7x+4,0,0\},\{0,0,0,0,6x+10,7x+4\}\}$$

Now as we recall, the main point for using QAPs in snarks is the fact, that solutions to R1CS are in 1:1 correspondence to the divisibility of a polynomial $p$, constructed from a R1CS solution and the polynomials of the QAP and the target polynomial.

So lets see this in our example. We already know from example XXX, that 
$I=\{1,2,3,4,6,11\}$ is a solution to the R1CS XXX of our problem. To see how this translates to polyinomial divisibility we compute the polynomial $p_I$ by
\begin{align*}
p_I(x)& = (\sum_{h\in |I|} I_h\cdot a_h(x))\cdot 
(\sum_{h\in |I|} I_h\cdot b_h(x)) - 
(\sum_{h\in |I|} I_h\cdot c_h(x)) \\
= & (2(6x+10)+6(7x+4))\cdot(3(6x+10)+4(7x+4))-(6(6x+10)+11(7x+4)) \\
= & ((12x+7)+(3x+11))\cdot((5x+4)+(2x+3))-((10x+8)+(12x+5)) \\
= & (2x+5)\cdot(7x+7)-(9x) \\
= & (x^{2}+2\cdot7x+5\cdot7x+5\cdot7)-(9x) \\
= & (x^{2}+x+9x+9)-(9x) \\
= & x^{2}+x+9
\end{align*}
And as we can see in this particular example $p_I(x)$ is equal to the target polynomial $t(x)$ and hence it is divisible by $t$ with $p/t=1$.

To give a counter example we already know from XXX that $I=\{1,2,3,4,8, 2\}$ is not a solution to our R1CS. To see how this translates to polyinomial divisibility we compute the polynomial $p_I$ by
\begin{align*}
p_I(x)& = (\sum_{h\in |I|} I_h\cdot a_h(x))\cdot 
(\sum_{h\in |I|} I_h\cdot b_h(x)) - 
(\sum_{h\in |I|} I_h\cdot c_h(x)) \\
= & (2(6x+10)+6(7x+4))\cdot(3(6x+10)+4(7x+4))-(6(6x+10)+11(7x+4)) \\
= & 8x^{2}+11x+3
\end{align*}
This polynomial is not divisible by the target polynomial $t$ since
Not divisible by $t$: $(8x^{2}+11x+3)/(x^{2}+x+9) =8+\frac{3x+8}{x^{2}+x+9} $
\end{example}



\subsection{Quadratic span programs}

\section{proof system}
% Intro from https://core.ac.uk/download/pdf/82198769.pdf


\subsection{Pairing Based SNARKS}
Technique. All pairing-based SNARKs in the literature follow a common paradigm
where the prover computes a number of group elements using generic group operations
and the verifier checks the proof using a number of pairing product equations. Bitansky
et al. [BCI+13] formalize this paradigm through the definition of linear interactive proofs
(LIPs). A linear interactive proof works over a finite field and the prover’s and verifier’s
messages consist of vectors of field elements. It furthermore requires that the prover
computes her messages using only linear operations. Once we have an approriate 2-move
LIP, it can be compiled into a SNARK by executing the equations “in the exponent”
using pairing-based cryptography. One source of our efficiency gain is that we design
a LIP system for arithmetic circuits where the prover only sends 3 field elements. In
comparison, the quadratic arithmetic programs by [GGPR13,PHGR13] correspond to
LIPs where the prover sends 4 field elements.
A second source of efficiency gain compared


Now a \textit{proof system} is nothing but a game between two parties, where one parties task is to convince the other party, that a given string over some alphabet is a statement is some agreed on language. To be more precise. Such a system is more over \textit{zero knowledge} if this possible without revealing any information about the (parts of) that string.
\begin{definition}[(Interactive) Proofing System]
% https://link.springer.com/content/pdf/10.1007/BF00195207.pdf
Let $L$ be some formal language over an alphabet $\Sigma$. Then an \textbf{interactive proof system} for $L$ is a pair $(P,V)$ of two probabilistic interactive algorithms, where $P$ is called the \textbf{prover} and $V$ is called the \textbf{verifier}. 

Both algorithms are able to send messages to one another. Each algorithm only sees its own state, some shared initial state and the communication messages. 

The verifier is bounded to a number of steps which is polynomial in the size of the shared initial state, after which it stops in an accept state or in a reject state. We impose no restrictions on the local computation conducted by the prover. 

We require that, whenever the verifier is executed the following two conditions hold:
\begin{itemize}
\item (Completeness) If a string $x\in \Sigma^*$ is a member of language $L$, that is $x\in L$ and both prover and verifier follow the protocol; the verifier will accept.
\item (Soundness) If a string $x\in \Sigma^*$ is not a member of language $L$, that is $x\notin L$ and the verifier follows the protocol; the verifier will not be convinced.
\item (Zero-knowledge) If a string $x\in \Sigma^*$ is a member of language $L$, that is $x\in L$ and the prover follows the protocol; the verifier will not learn anything about $x$ but $x\in L$.
\end{itemize}
\end{definition}

In the context of zero knowledge proving systems definition XXX gets a slight adaptation:
\begin{itemize}
\item Instance: Input commonly known to both prover (P) and verifier (V), and used to support the statement of what needs to be proven. This common input may either be local to the prover-verifier interaction, or public in the sense of being known by external parties (Some scientific articles use "instance" and "statement" interchangeably, but we distinguish between the two.).
\item Witness: Private input to the prover. Others may or may not know something about the witness.
\item Relation: Specification of relationship between instances and witness. A relation can be viewed as a set of permissible pairs (instance, witness).
\item Language: Set of statements that appear as a permissible pair in the given relation.
\item Statement:Defined by instance and relation. Claims the instance has a witness in the relation(which is either true or false).
\end{itemize}

The following subsections define ways to describe checking relations that are particularly useful in the context of zero knowledge proofing systems

\subsection{Succinct NIZK}
Preprocessing style: trusted setup, multi party ceremony

Blum, Feldman and Micali
% Manuel  Blum,  Paul  Feldman,  and  Silvio  Micali.   Non-interactive  zero-knowledge  and  itsapplications.  InSTOC, pages 103–112, 1988.
 extended the notion tonon-interactivezero-knowledge(NIZK)  proofs in the  common  reference  string  model.  NIZK  proofs  are  useful  in  theconstruction of non-interactive cryptographic schemes, e.g., digital signatures and CCA-secure public key encryption.
 
\begin{definition} 
Let $\mathcal{R}$ be a relation generator that given a security parameter $\lambda$ in unary returns a polynomial time decidable binary relation $R$. For pairs $(i,w)\in R$ we call $i$ the instance\footnote{Note that in Groth16 this is called the statement. We think the term instance is more consistent with SOMETHING. } and $w$ the witness. We define $R_\lambda$ to be the set of possible relations $R$ the relation generator may output given $1^\lambda$. We will in the following for notational simplicity assume $\lambda$ can be deduced from the description of $R$. The relation generator may also output some side information, an auxiliary input $z$, which will be given to the adversary. An efficient prover publicly verifiable non-interactive argument for $R$ is a quadruple of probabilistic polynomial algorithms $(\textsc{Setup},\textsc{Prove},\textsc{Vfy},\textsc{Sim})$ such 
\begin{itemize}
\item Setup: $(CRS,\tau)\rightarrow Setup(R)$: The setup produces a common reference string $CRS$ and a simulation trapdoor $\tau$ for the relation $R$.
\item Proof: $\pi\rightarrow Prove(R,CRS,i,w)$: The prover algorithm takes as input a common reference string $CRS$ and a statement $(i,w)\in R$ and returns an argument $\pi$.
\item Verify: $0/1\rightarrow Vfy(R,CRS,i,\pi)$: The  verification algorithm  takes as input a common reference string $CRS$, an instance $i$ and an argument $\pi$ and returns 0 (reject) or 1 (accept).
\item $\pi\rightarrow Sim(R,\tau,i)$: The simulator takes as input a simulation trapdoor $\tau$ and instance $i$ and returns an argument $\pi$. 
\end{itemize}
\end{definition}

\paragraph{Common Reference String Generation}
Also called trusted setup phase. The field elements needed in this step are called toxic waste ...

\subparagraph{Trusted third party} The most simple approach to generate a common reference string is a so called \textit{trusted third party}. By assumption the entire systems trusts this party to generate the common reference string exactly accoring to the rules and the party will delete all traces of the toxic waste after CRS generation.

\subparagraph{Player exchangeable Multi Party Ceremonies}

Achive soundness if only a single party is honest and correctly deletes toxix waste. Is always zero knowledge.

State of the art
%https://eprint.iacr.org/2017/1050.pdf
works in the random beacon model. 

A random beacon produces publicly available and verifyable random values at fixed intervals. The difference between random beacons and random oracles, is that random beacons are not available until certain time slots. Random beacons can be instanciated for example by evaluation of say $2^{40}$ iterations of SHA256 on some high entropy, publically available data like the closing value of the stock market on a certain date, the output of a selected set of national lotteries and so on. 

The assumption is that any given random beacon value contains large amounts of entropy that is independent from the influence of an adversary in previous time slots. 




\subsubsection{Groth16}
Groth’s  constant  size  NIZK  argument  is  based  on  constructing  a  set  of  polynomial equations and using pairings to efficiently verify these equations. Gennaro, Gentry,Parno and Raykova [Pinocchio] found an insightful construction of polynomial equations based on Lagrange interpolation polynomials yielding a pairing-based NIZK argumentwith a common reference string size proportional to the size of the statement and wit-ness.

It constructs a snark  for arithmetic circuit satisfiability, where a proof consists of only 3 group elements. In addition to being small, the proof is also easy to verify. The verifier just needs to compute a number of exponentiations proportional to the instance size and check a single pairing product equation, which only  has  3  pairings.  

The  construction  can  be  instantiated  with  any  type  of  pairings including Type III pairings, which are the most efficient pairings. The argument has perfect completeness and perfect zero-knowledge. For soundness ?? 

In the common reference string model.

Setup: 
\begin{itemize}
\item random elements $\alpha,\beta,\gamma, \delta, s \in \mathbb{F}_{scalar}$ 
\item Common reference string $CRS_{QAP}$, specific to the $QAP$ and the choice of statement and witness $CRS_{QAP}= (CRS_{\mathbb{G}_1},CRS_{\mathbb{G}_2})$, with $n=deg(t)$: 
$$
CRS_{\mathbb{G}_{1}}=\left\{ \begin{array}{c}
[\alpha]g,[\beta]g,[\delta]g,\left\{ [s^{k}]g\right\} _{k=0}^{n-1},\left\{ [\frac{\beta a_{k}(s)+\alpha b_{k}(s)+c_{k}(s)}{\gamma}]g\right\} _{k\in I}\\
\left\{ [\frac{\beta a_{k}(s)+\alpha b_{k}(s)+c_{k}(s)}{\delta}]g\right\} _{k\in W},\left\{ [\frac{s^{k}t(s)}{\delta}]g\right\} _{k=0}^{n-2}
\end{array}\right\} 
$$
$$
CRS_{\mathbb{G}_{2}}=\left\{ [\beta]h ,[\gamma]h,[\delta]h,\left\{[s^k]h\right\} _{k=0}^{n-1}\right\} 
$$
\item Toxic waste: Must delete random elements after $CRS_{QAP}$ generation.
\end{itemize} 

\begin{example}[Generalized factorization snark]
\label{main_example_2_5}
In this example we want to compile our main example in Groth16. Input is the R1CS from example \ref{main_example_2_4}. We choose the following global parameters

\begin{tabular}{ccccc}
\\
curve = BLS6-6 & $\mathbb{G}_1=$ BLS6-6(13) & $g = (13,15) $
& $\mathbb{G}_2=$ & $h=(7v^2,16v^3)$ and $\mathbb{G}_T = \F_{43^6}^*$.
\end{tabular} 
\end{example}
\begin{example}[Trusted third party for the factorization snark]
We consider ourself as a trusted third part to generate the common reference string for our generalized factorization snark. We therefore choose the following secret field elements $\alpha=6$, $\beta=5$, $\gamma=4$, $\delta=3$, $s=2$ from $\mathbb{F}_{13}$ and are very careful to hide them from anyone how hasn't read this book. From those values we can then instantiate the common reference string XXX:
$$
CRS_{\mathbb{G}_{1}}=\left\{ \begin{array}{c}
[6](13,15),[5](13,15),[3](13,15),\left\{ [s^{k}](13,15)\right\} _{k=0}^{1},\left\{ [\frac{5 a_{k}(2)+6 b_{k}(2)+c_{k}(2)}{4}](13,15)\right\} _{k\in S}\\
\left\{ [\frac{5 a_{k}(2)+6 b_{k}(2)+c_{k}(2)}{3}](13,15)\right\} _{k\in W},\left\{ [\frac{s^{k}t(2)}{3}](13,15)\right\} _{k=0}^{0}
\end{array}\right\}
$$
Since we have instance indices $I=\{1, in_1,in_2\}$ and witness indices $W=\{in_3,mid_1,out_1\}$ we have 
The instance parts.
\begin{multline*}
\left[\frac{5 a_{c}(2)+6 b_{c}(2)+c_{c}(2)}{4}\right](13,15) = 
\left[\frac{5\cdot 0 +6\cdot 0 + 0 }{4}\right](13,15) =
\left[0\right](13,15) = \mathcal{O}
\end{multline*}
\begin{multline*}
\left[\frac{5 a_{in_3}(2)+6 b_{in_3}(2)+c_{in_3}(2)}{4}\right](13,15) =
\left[(5\cdot 0+6\cdot(7\cdot 2 +4)+0)\cdot 10\right](13,15) =\\
\left[(6\cdot 5 )\cdot 10\right](13,15) =
\left[1\right](13,15) =
(13,15)
\end{multline*}
\begin{multline*}
\left[\frac{5 a_{out}(2)+6 b_{out}(2)+c_{out}(2)}{4}\right](13,15) = 
\left[(5\cdot 0 +6\cdot 0 + (7\cdot 2 + 4))\cdot 10 \right](13,15) =\\
\left[5\cdot 10 \right](13,15) =
\left[11\right](13,15) = 
(33,9)
\end{multline*}

Witness part:
\begin{multline*}
\left[\frac{5 a_{in_1}(2)+6 b_{in_1}(2)+c_{in_1}(2)}{3}\right](13,15) = 
\left[(5\cdot (6\cdot 2 +10) +6\cdot 0 +0 )\cdot 9\right](13,15) = \\
\left[(5\cdot 9)\cdot 9\right](13,15) =
\left[2\right](13,15) = (33,34)
\end{multline*}
\begin{multline*}
\left[\frac{5 a_{in_2}(2)+6 b_{in_2}(2)+c_{in_2}(2)}{3}\right](13,15) = 
\left[(5\cdot 0 +6\cdot (6\cdot 2 + 10) + 0 )\cdot 9\right](13,15) = \\
\left[(6\cdot 9)\cdot 9\right](13,15) =
\left[5\right](13,15) =
(26,34)
\end{multline*}
\begin{multline*}
\left[\frac{5 a_{mid_1}(2)+6 b_{mid_1}(2)+c_{mid_1}(2)}{3}\right](13,15) = 
\left[(5\cdot (7\cdot 2 + 4) +6\cdot 0 + 0 )\cdot 9\right](13,15) = \\
\left[(5\cdot 5)\cdot 9\right](13,15) =
\left[4\right](13,15) =
(35,28)
\end{multline*}
For $\left\{\left[\frac{s^{k}t(2)}{3}\right](13,15)\right\} _{k=0}^{0}$ we get
\begin{multline*}
\left[\frac{2^{0}t(2)}{3}\right](13,15)=
[t(2)\cdot 9](13,15)= 
[(2^2+2+9)\cdot 9](13,15)= 
[5](13,15) =
(26,34)
\end{multline*}
All together, the $\mathbb{G}_1$ part of the CRS is:
$$
CRS_{\mathbb{G}_{1}}=\left\{ \begin{array}{c}
(27,34),(26,34),(38,15),\left\{(13,15),(33,34)\right\},
\left\{\mathcal{O}, (13,15), (33,9)\right\}\\
\left\{(33,34),(26,34),(35,28)\right\},
\left\{(26,34)\right\}
\end{array}\right\}
$$
To compute the $\mathbb{G}_2$ part 
$$
CRS_{\mathbb{G}_{2}}=\left\{ [5](7v^2,16v^3) ,[4](7v^2,16v^3),[3](7v^2,16v^3),\left\{[2^k](7v^2,16v^3)\right\} _{k=0}^{1}\right\} 
$$
$$
CRS_{\mathbb{G}_{2}}=\left\{ [5](7v^2,16v^3) ,[4](7v^2,16v^3),[3](7v^2,16v^3),\left\{[1](7v^2,16v^3), [2](7v^2,16v^3)\right\}\right\} 
$$
$$
CRS_{\mathbb{G}_{2}}=\left\{(16v^2,28v^3) ,(37v^2,27v^3),(42v^2,16v^3),\left\{(7v^2,16v^3), (10v^2,28v^3)\right\}\right\} 
$$

So alltogether our common reference string is 
$$
\begin{pmatrix}
\left\{ \begin{array}{c}
(27,34),(26,34),(38,15),\left\{(13,15),(33,34)\right\},
\left\{\mathcal{O}, (13,15), (33,9)\right\}\\
\left\{(33,34),(26,34),(35,28)\right\},
\left\{(26,34)\right\}
\end{array}\right\}\\
\left\{(16v^2,28v^3) ,(37v^2,27v^3),(42v^2,16v^3),\left\{(7v^2,16v^3), (10v^2,28v^3)\right\}\right\}
\end{pmatrix}
$$
\end{example}
\begin{example}[Player exchangeable multi party ceremony for the factorization snark] In this example we want to simulate a real world player exchangeable multi party ceremony for our factorization snark XXX as explained in XXX.

We use our TinyMD5 hash function XXX to hash to $\mathbb{G}_2$.


We assume that we have a coordinator $Alice$ together with three parties $Bob$, $Carol$ and $Dave$ that want to contribute their randomness to the protocol. Since the degree $n$ of the target polynomial is $2$, we need to compute the common reference string
$$
CRS= \left\{\right\}
$$
For contributer $j>0$ in phase $l$ to compute the proof of knowledge XXX, we need to define the $transcript_{l,j-1}$ of the previous round. We define it as sha256 of $MPC_{l,j-1}$. To be more precise we define
$$
transcript_{1,j-1}= 
MD5(
'[s]g_1 [s]g_2 [s^2] g_1 [\alpha]g_1 [\alpha\cdot s]g_1
[\beta]g_1 [\beta]g_2[\beta \cdot s]g_1'
)
$$
The only thing actually important about the transcript, is that it is publically available data that is not accesable for anyone before the MPC-data of round $j-1$ in phase $l$ exists.

We start with the first round usually called the 'powers of tau' EXPLAIN THAT TERM...
The computation is initialized With $s=1$, $\alpha=1$, $\beta=1$. Hence the computation starts with the following data
$$
MPC_{1,0}= \left\{
\begin{array}{lcl}
([s]g_1, [s]g_2) &=& ((13,15),(7v^2,16v^3))\\ 
{}[s^2] g_1 &=& (13,15)\\
{}[\alpha]g_1 &=& (13,15)\\ 
{}[\alpha\cdot s]g_1 &=& (13,15)\\ 
([\beta]g_1,[\beta]g_2) &=& ((13,15),(7v^2,16v^3))\\ 
{}[\beta \cdot s]g_1 &=& (13,15)
\end{array}
\right\}
$$
Then 
\begin{multline*}
transcript_{1,0}=\\ 
MD5('(13,15)(7v^2,16v^3)(13,15)(13,15)(13,15)(13,15)(7v^2,16v^3)(13,15)') =\\ f2baea4d3dba5eef5c63bb210920e7d9
\end{multline*}
We obtain that hash by computing

$printf '\%s' "(13,15)(7v\textasciicircum 2,16v\textasciicircum 3)(13,15)(13,15)(13,15)(13,15)(7v\textasciicircum 2,16v\textasciicircum 3)(13,15)" | md5sum$
% note the actual code is printf '%s' "(13,15)(7v^2,16v^3)(13,15)(13,15)(13,15)(13,15)(7v^2,16v^3)(13,15)" | md5sum

Everyone agreed, that the MPC starts on the 21.03.2020 and everyone can contribute for exactly a year until the 20.03.2021. 


  
It then proceeds in a round robin style, starting with Bob, who optains that data in $MPC_{1,0}$ and then computes his contribution. Lets assume that $Bob$ is honest and that bought 
a 13-sided dice (PICTURE OF 13-SIDED DICE) to randomly find three secret field values from our prime field $\F_{13}$. He though the dice and got $\alpha = 4$, $\beta=8$ and $s= 2$. He then updates $MPC_{1,0}$:  
$$
MPC_{1,1}= \left\{
\begin{array}{lclcl}
([s]g_1, [s]g_2) &=& ([2](13,15),[2](7v^2,16v^3)) &=& ((33,34),(10v^2,28v^3))\\ 
{}[s^2] g_1 &=& [4](13,15)&=& (35,28)\\
{}[\alpha]g_1 &=& [4](13,15)&=& (35,28)\\ 
{}[\alpha\cdot s]g_1 &=& [8](13,15) &=& (26,9)\\ 
([\beta]g_1,[\beta]g_2) &=& ([8](13,15),[8](7v^2,16v^3))&=& ((26,9),(16v^2,15v^3))\\ 
{}[\beta \cdot s]g_1 &=& [3](13,15)&=& (38,15)
\end{array}
\right\}
$$
In addition he compute 
$$
POK_{1,1} \left\{
\begin{array}{lcl}
y_{s} &=& POK(2, f2baea4d3dba5eef5c63bb210920e7d9) = ((33,34),(16v^2 , 28v^3))\\
y_{\alpha} &=& POK(4, f2baea4d3dba5eef5c63bb210920e7d9) = ((35,28),(10v^2 , 15v^3))\\ 
y_{\beta} &=& POK(8, f2baea4d3dba5eef5c63bb210920e7d9) = ((26,9),(16v^2 , 28v^3))\\
\end{array}
\right\}
$$
since $[s]g_1 = (33,34)$, $[\alpha] g_1 = (35,28)$ and $[\beta] g_1 = (26,9)$. as well as 
\begin{align*}
TinyMD5_{2}('(33,34)f2baea4d3dba5eef5c63bb210920e7d9') =\\ H_2(MD5('(33,34)f2baea4d3dba5eef5c63bb210920e7d9').trunc(3))=\\ H_2(2066b3b6b6d97c46c3ac6ee2ccd23ad9.trunc(3))= H_2(ad9) = \\
H_2(101 011 011 001)=\\
[8\cdot 4^{1}\cdot 5^{0}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{0}\cdot 3^{1}\cdot 8^{1}](42v^2 , 16v^3 )+\\
[2\cdot 3^{0}\cdot 9^{1}\cdot 11^{1}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{0}\cdot 10^{1}](10v^2 , 15v^3 ) =\\
[8\cdot 4\cdot 7](7v^2 , 16v^3)+
[12\cdot 3\cdot 8](42v^2 , 16v^3 )+
[2\cdot 9\cdot 11](17v^2 , 15v^3 ) +
[3\cdot 10](10v^2 , 15v^3 ) =\\
[8\cdot 4\cdot 7](7v^2 , 16v^3)+
[12\cdot 3\cdot 8](42v^2 , 16v^3 )+
[2\cdot 9\cdot 11](17v^2 , 15v^3 ) +
[3\cdot 10](10v^2 , 15v^3 ) =\\
[3](7v^2 , 16v^3)+
[2](42v^2 , 16v^3 )+
[3](17v^2 , 15v^3 ) +
[4](10v^2 , 15v^3 )=\\
[3](7v^2 , 16v^3)+
[2*3](7v^2 , 16v^3 )+
[3*7](7v^2 , 16v^3 ) +
[4*11](7v^2 , 16v^3 )=\\
(42v^2 , 16v^3)+
(17v^2 , 28v^3 )+
(16v^2 , 15v^3 ) +
(16v^2 , 28v^3 )=\\
[3](7v^2 , 16v^3)+
[6](7v^2 , 16v^3 )+
[8](7v^2 , 16v^3 ) +
[5](7v^2 , 16v^3 )=\\
[3+6+8+5](7v^2 , 16v^3)=
(37v^2 , 16v^3 )
\end{align*}
So we get $[2](37v^2 , 16v^3 )= (16v^2 , 28v^3 )$

===================

\begin{align*}
TinyMD5_{2}('(35,28)f2baea4d3dba5eef5c63bb210920e7d9') =\\ H_2(MD5('(35,28)f2baea4d3dba5eef5c63bb210920e7d9').trunc(3))=\\ H_2(ad54fa3674f6a84fab9208d7a94c9163.trunc(3))= H_2(163) = \\
H_2(000 101 100 011)=\\
[8\cdot 4^{0}\cdot 5^{0}\cdot 7^{0}](7v^2 , 16v^3)+
[12\cdot 1^{1}\cdot 3^{0}\cdot 8^{1}](42v^2 , 16v^3 )+\\
[2\cdot 3^{1}\cdot 9^{0}\cdot 11^{0}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{1}\cdot 10^{1}](10v^2 , 15v^3 ) = \\
[8](7v^2 , 16v^3)+
[12\cdot 8](42v^2 , 16v^3 )+
[2\cdot 3](17v^2 , 15v^3 ) +
[3\cdot 9\cdot 10](10v^2 , 15v^3 ) = \\
[8](7v^2 , 16v^3)+
[5](42v^2 , 16v^3 )+
[6](17v^2 , 15v^3 ) +
[10](10v^2 , 15v^3 ) = \\
[8](7v^2 , 16v^3)+
[5*3](7v^2 , 16v^3 )+
[6*7](7v^2 , 16v^3 ) +
[10*11](7v^2 , 16v^3 )=\\
(16v^2 , 15v^3)+
(10v^2 , 28v^3 )+
(42v^2 , 16v^3 ) +
(17v^2 , 28v^3 )=\\
[8](7v^2 , 16v^3)+
[2](7v^2 , 16v^3 )+
[3](7v^2 , 16v^3 ) +
[6](7v^2 , 16v^3 )=\\
[8+2+3+6](7v^2 , 16v^3)=
(17v^2 , 28v^3 )
\end{align*}
So we get $[4](17v^2 , 28v^3 )= (10v^2 , 15v^3 )$

\begin{align*}
TinyMD5_{2}('(26,9)f2baea4d3dba5eef5c63bb210920e7d9') =\\ H_2(MD5('(26,9)f2baea4d3dba5eef5c63bb210920e7d9').trunc(3))=\\ H_2(b87b632f7027ad78cadc2452beb30e9a.trunc(3))= H_2(e9a) = \\
H_2(111 010 011 010)=\\
[8\cdot 4^{1}\cdot 5^{1}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{0}\cdot 3^{1}\cdot 8^{0}](42v^2 , 16v^3 )+\\
[2\cdot 3^{0}\cdot 9^{1}\cdot 11^{1}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{1}\cdot 10^{0}](10v^2 , 15v^3 )= \\
[8\cdot 4\cdot 5\cdot 7](7v^2 , 16v^3)+
[12\cdot 3](42v^2 , 16v^3 )+
[2\cdot 9\cdot 11](17v^2 , 15v^3 ) +
[3\cdot 9](10v^2 , 15v^3 )= \\
[2](7v^2 , 16v^3)+
[10](42v^2 , 16v^3 )+
[3](17v^2 , 15v^3 ) +
[1](10v^2 , 15v^3 )= \\
[2](7v^2 , 16v^3)+
[10*3](7v^2 , 16v^3 )+
[3*7](7v^2 , 16v^3 ) +
[1*11](7v^2 , 16v^3 )=\\
(10v^2 , 28v^3)+
(37v^2 , 27v^3 )+
(16v^2 , 15v^3 ) +
(10v^2 , 15v^3 )=\\
[2](7v^2 , 16v^3)+
[4](7v^2 , 16v^3 )+
[8](7v^2 , 16v^3 ) +
[11](7v^2 , 16v^3 )=\\
[2+4+8+11](7v^2 , 16v^3)=
(7v^2 , 27v^3 )
\end{align*}
So we get $[8](17v^2 , 28v^3 )= (16v^2 , 28v^3 )$

So Bob publishes $MPC_{1,1}$ as well as $POK_{1,1}$ and after that its Carols turn. Lets also assume that Carrol is honest. So Carol looks at Bobs data and compute the transcript according to our rules
\begin{multline*}
transcript_{1,1}=\\ 
MD5('
(33,34)(10v^2,28v^3)(35,28)(35,28)(26,9)(26,9)(16v^2,15v^3)(38,15)') =\\ fe72e18b90014062682a77136944e362
\end{multline*}
We obtain that hash by computing

$printf '\%s' "(33,34)(10v^2,28v^3)(35,28)(35,28)(26,9)(26,9)(16v^2,15v^3)(38,15)" | md5sum$

Carol then computes here contribution. Since she is honest she chooses randomly three secret field values from our prime field $\F_{13}$, by invoking her compter. She found $\alpha = 3$, $\beta=4$ and $s= 9$ and updates $MPC_{1,1}$:  
$$
MPC_{1,2}= \left\{
\begin{array}{lclcl}
([s]g_1, [s]g_2) &=& ([9](33,34),[9](10v^2,28v^3)) &=&  ((26,34),(16v^2,28v^3))\\ 
{}[s^2] g_1 &=& [9\cdot 9](35,28) &=& (13,28)\\
{}[\alpha]g_1 &=& [3](35,28) &=& (13,28) \\ 
{}[\alpha\cdot s]g_1 &=& [3\cdot 9](26,9) &=& (26,9)\\ 
([\beta]g_1,[\beta]g_2) &=& ([4](26,9),[4](16v^2,15v^3)) &=& ((27,34),(17v^2,28v^3))\\ 
{}[\beta \cdot s]g_1 &=& [4\cdot 9](38,15) &=& (35,28)
\end{array}
\right\}
$$
In addition he compute 
$$
POK_{1,2} \left\{
\begin{array}{lcl}
y_{s} &=& POK(9, fe72e18b90014062682a77136944e362) = ((35,15),(17v^2 , 28v^3))\\
y_{\alpha} &=& POK(3, fe72e18b90014062682a77136944e362) = ((38,15),(17v^2 , 15v^3 ))\\ 
y_{\beta} &=& POK(4, fe72e18b90014062682a77136944e362) = ((35,28),(42v^2 , 27v^3 ))\\
\end{array}
\right\}
$$

\begin{align*}
TinyMD5_{2}('(35,15)fe72e18b90014062682a77136944e362') =\\ H_2(MD5('(35,15)fe72e18b90014062682a77136944e362').trunc(3))=\\ H_2(115f145ceffdda73e916dc5ba8ae7354.trunc(3))= H_2(354) = \\
H_2(001 101 010 100)=\\
[8\cdot 4^{0}\cdot 5^{0}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{1}\cdot 3^{0}\cdot 8^{1}](42v^2 , 16v^3 )+\\
[2\cdot 3^{0}\cdot 9^{1}\cdot 11^{0}](17v^2 , 15v^3 ) +
[3\cdot 6^{1}\cdot 9^{0}\cdot 10^{0}](10v^2 , 15v^3 )= \\
[8\cdot 7](7v^2 , 16v^3)+
[12\cdot 8](42v^2 , 16v^3 )+
[2\cdot 9](17v^2 , 15v^3 ) +
[3\cdot 6](10v^2 , 15v^3 )= \\
[4](7v^2 , 16v^3)+
[5](42v^2 , 16v^3 )+
[5](17v^2 , 15v^3 ) +
[5](10v^2 , 15v^3 )= \\
[4](7v^2 , 16v^3)+
[5*3](7v^2 , 16v^3 )+
[5*7](7v^2 , 16v^3 ) +
[5*11](7v^2 , 16v^3 )=\\
(37v^2 , 27v^3)+
(10v^2 , 28v^3 )+
(37v^2 , 16v^3 ) +
(42v^2 , 16v^3 )=\\
[4](7v^2 , 16v^3)+
[2](7v^2 , 16v^3 )+
[9](7v^2 , 16v^3 ) +
[3](7v^2 , 16v^3 )=\\
[4+2+9+3](7v^2 , 16v^3)=
(16v^2 , 28v^3 )
\end{align*}
So we get $[9](16v^2 , 28v^3 )= (17v^2 , 28v^3 )$

\begin{align*}
TinyMD5_{2}('(38,15)fe72e18b90014062682a77136944e362') =\\ H_2(MD5('(38,15)fe72e18b90014062682a77136944e362').trunc(3))=\\ H_2(cc4da0c02c4c1b15e72d6cc6430206ab.trunc(3))= H_2(6ab) = \\
H_2(011 010 101 011)=\\
[8\cdot 4^{0}\cdot 5^{1}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{0}\cdot 3^{1}\cdot 8^{0}](42v^2 , 16v^3 )+\\
[2\cdot 3^{1}\cdot 9^{0}\cdot 11^{1}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{1}\cdot 10^{1}](10v^2 , 15v^3 )= \\
[8\cdot 5\cdot 7](7v^2 , 16v^3)+
[12\cdot 3](42v^2 , 16v^3 )+
[2\cdot 3\cdot 11](17v^2 , 15v^3 ) +
[3\cdot 9\cdot 10](10v^2 , 15v^3 )= \\
[7](7v^2 , 16v^3)+
[10](42v^2 , 16v^3 )+
[1](17v^2 , 15v^3 ) +
[10](10v^2 , 15v^3 )= \\
[7](7v^2 , 16v^3)+
[10*3](7v^2 , 16v^3 )+
[1*7](7v^2 , 16v^3 ) +
[10*11](7v^2 , 16v^3 )=\\
(17v^2 , 15v^3)+
(17v^2 , 28v^3 )+
(17v^2 , 15v^3 ) +
(17v^2 , 28v^3 )=\\
[7](7v^2 , 16v^3)+
[4](7v^2 , 16v^3 )+
[7](7v^2 , 16v^3 ) +
[6](7v^2 , 16v^3 )=\\
[7+4+7+6](7v^2 , 16v^3)=
(10v^2 , 15v^3)
\end{align*}
So we get $[3](10v^2 , 15v^3 )= (17v^2 , 15v^3 )$

\begin{align*}
TinyMD5_{2}('(35,28)fe72e18b90014062682a77136944e362') =\\ H_2(MD5('(35,28)fe72e18b90014062682a77136944e362').trunc(3))=\\ H_2(502323bc55c75f7189fad7999c9f1708.trunc(3))= H_2(708) = \\
H_2(011 100 001 000)=\\
[8\cdot 4^{0}\cdot 5^{1}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{1}\cdot 3^{0}\cdot 8^{0}](42v^2 , 16v^3 )+\\
[2\cdot 3^{0}\cdot 9^{0}\cdot 11^{1}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{0}\cdot 10^{0}](10v^2 , 15v^3 )= \\
[8\cdot 5\cdot 7](7v^2 , 16v^3)+
[12](42v^2 , 16v^3 )+
[2\cdot 11](17v^2 , 15v^3 ) +
[3](10v^2 , 15v^3 )= \\
[7](7v^2 , 16v^3)+
[12](42v^2 , 16v^3 )+
[9](17v^2 , 15v^3 ) +
[3](10v^2 , 15v^3 )= \\
[7](7v^2 , 16v^3)+
[12*3](7v^2 , 16v^3 )+
[9*7](7v^2 , 16v^3 ) +
[3*11](7v^2 , 16v^3 )=\\
(17v^2 , 15v^3)+
(42v^2 , 27v^3 )+
(10v^2 , 15v^3 ) +
(17v^2 , 15v^3 )=\\
[7](7v^2 , 16v^3)+
[10](7v^2 , 16v^3 )+
[11](7v^2 , 16v^3 ) +
[7](7v^2 , 16v^3 )=\\
[7+10+11+7](7v^2 , 16v^3)=
(37v^2 , 16v^3)
\end{align*}
So we get $[4](37v^2 , 16v^3 )= (42v^2 , 27v^3 )$

Dave thinks he can outsmart the syste, Since he is the last to contribute, he just makes up an entirely new $MPC$, that does not contain any randomness from the previous contributers. He thinks he can do that because, no one can distinguish his $MPC_{1,3}$ from a correct one. If this is done in a smart way, he will even be able to compute the correct $POK$s. 

So Dave choses $s=12$, $\alpha=11$ and $\beta=10$ and he will keep those values, hoping to be able to use them later to forge false proofs in the factorization snark. He then compute  
$$
MPC_{1,3}= \left\{
\begin{array}{lcl}
([s]g_1, [s]g_2) &=& ((13,28),(7v^2,27v^3))\\ 
{}[s^2] g_1 &=& (13,15)\\
{}[\alpha]g_1 &=& (33,9)\\ 
{}[\alpha\cdot s]g_1 &=& (33,34)\\ 
([\beta]g_1,[\beta]g_2) &=& ((38,28),(42v^2,27v^3))\\ 
{}[\beta \cdot s]g_1 &=& (38,15)
\end{array}
\right\}
$$
Dave does not delete $s$, $\alpha$ and $\beta$, because if this is accepted as phase one of the common reference string computation, Dave controls already $3/4$-th of the cheating key to forge proofs. So Dave is careful to get the proofs of knowledge right. He computes the transcript of Carols contribution as 

\begin{multline*}
transcript_{1,2}=\\ 
MD5('
(26,34)(16v^2,28v^3)(13,28)(13,28)(26,9)(27,34)(17v^2,28v^3)(35,28)') =\\ c8e6308fffd47009f5f65e773ae4b499
\end{multline*}

We obtain that hash by computing

$printf '\%s' "(26,34)(16v^2,28v^3)(13,28)(13,28)(26,9)(27,34)(17v^2,28v^3)(35,28)" | md5sum$

\end{example}
