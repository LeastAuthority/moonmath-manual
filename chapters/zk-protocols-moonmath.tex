\chapter{Zero Knowledge Protocols}
\label{chapter:zk-protocols}
% Intro from https://core.ac.uk/download/pdf/82198769.pdf
% CONTAINS NICE HIHG LEVEL STUFF
% Term SNARK was introduced in  Bitansky, Nir; Canetti, Ran; Chiesa, Alessandro; Tromer, Eran (January 2012). ``From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again''
A so-called \term{zero-knowledge protocol} is a set of mathematical rules by which one party, usually called \term{the prover}, can convince another party, usually called \term{the verifier}, that given some instance, the prover knows some witness for that instance, without revealing any information about the witness. 

As we have seen in \chaptname{} \ref{chap:statements}, given some language $L$ and instance $I$, the knowledge claim ``there is a witness $W$ such that  $(I;W)$ is a word in $L$'' is constructively provable by providing the witness $W$ to the verifier. The verifier can then use the grammar of the language to verify the proof. In contrast, it's the challenge of any zero-knowledge protocol to enable a prover to prove knowledge of a witness to any verifier, without revealing any information about the witness beyond its existence.

In this chapter, we look at various systems that exist to solve this task. We start with an introduction to the basic concepts and terminology in zero-knowledge proving systems and then introduce the so-called Groth\_16 protocol as one of the most efficient systems. We will update this chapter with other zero-knowledge proof systems in future versions of this book.

\section{Proof Systems}
From an abstract point of view, a proof system is a set of rules which models the generation and exchange of messages between two parties, usually called the prover and the verifier. The purpose of a proof system is to ascertain whether a given string belongs to a formal language or not.  

Proof systems are often classified by certain trust assumptions and the computational capabilities of the prover and the verifier. In its most general form, the prover usually possesses unlimited computational resources but cannot be trusted, while the verifier has bounded computational power but is assumed to be honest.

Proving membership or knowledge claims of a statement for some string as explained in \chaptname{} \ref{chap:statements} is executed by the generation of certain messages that are sent between prover and verifier, until the verifier is convinced that the string is a word in the language in consideration.

% https://link.springer.com/content/pdf/10.1007/BF00195207.pdf
To be more specific, let $\Sigma$ be an alphabet, and let $L$ be a formal language defined over $\Sigma$. Then a \term{proof system} for language $L$ is a pair of probabilistic interactive algorithms $(P,V)$, where $P$ is called the \term{prover} and $V$ is called the \term{verifier}. 

Both algorithms are able to send messages to one another, each algorithm has its own state, some shared initial state and access to the messages. The verifier is bounded to a number of steps which is polynomial in the size of the shared initial state, after which it stops and outputs either \texttt{accept} or \texttt{reject} indicating that it accepts or rejects a given string to be a word in $L$ or not. In contrast, in the most general form of a proof system, there are no bounds on the computational power of the prover.

When the execution of the verifier algorithm stops the following conditions are required to hold:
\begin{itemize}
\item (Completeness) If the string $x\in \Sigma^*$ is a word in language $L$ and both prover and verifier follow the protocol, the verifier outputs \texttt{accept}.
\item (Soundness) If the string $x\in \Sigma^*$ is not a word in language $L$ and the verifier follows the protocol, the verifier outputs \texttt{reject}, except with some small probability.
\end{itemize}
In addition, a proof system is called \term{zero-knowledge} if the verifier learns nothing about $x$ other than $x\in L$. 

The previous definition of proof systems is very general, and many subclasses of proof systems are known in the field. For example, some proof systems restrict the computational power of the prover, while some proof systems assume that the verifier has access to randomness. In addition, proof systems are classified by the number of messages that can be exchanged. If the system only requires to send a single message from the prover to the verifier, the proof system is called \term{non-interactive}, because no interaction other then sending the actual proof is required. In contrast, any other proof system is called \term{interactive}.

A proof system is usually called \term{succinct} if the size of the proof is shorter than the witness necessary to generate the proof. Moreover, a proof system is called \term{computationally sound} if soundness only holds under the assumption that the computational capabilities of the prover are polynomial bound. To distinguish general proofs from computationally sound proofs, the latter are often called \term{arguments}.

Since the term \term{zk-SNARKs} is an abbreviation for "Zero-knowledge, succinct, non-interactive argument of knowledge", proof system able to generate zk-SNARKS therefore have the zero-knowledge property, are able to generate proofs that require less space then the original witness and require no interaction between prover and verifier, other then transmitting the zk-SNARK itself. However those systems are only sound under the assumption that the prover's computational capabilities are polynomial bound.
\begin{example}[Constructive Proofs for Algebraic Circuits] We have seen in \ref{circuit-satisfiability} how algebraic circuit give rise to formal languages and constructive proofs for knowledge claims.

To reformulate this notion of constructive proofs for algebraic circuits into a proof system, let $\F$ be a finite field, and let $C(\F)$ be an algebraic circuit over $\F$ with associated language $L_{C(\F)}$. A non-interactive proof system for $L_{C(\F)}$ is given by the following two algorithms:

\term{Prover Algorithm}: The prover $P$ is defined by circuit execution. Given some instance $I$ the prover executes circuit $C(\F)$ to compute a witness $W$ such that the pair $(I;W)$ is a valid assignment to $C(\F)$ whenever the circuit is satisfiable for $I$. The prover then sends the constructive proof $(I;W)$ to the verifier.

\term{Verifier Algorithm}: On receiving a message $(I;W)$, the verifier algorithm $V$ inserts $(I;W)$ into the associated R1CS of the circuit. If $(I;W)$ is a solution to the $R1CS$, the verifier returns \texttt{accepts}, if not, it returns \texttt{reject}. 

To see that this proof system is complete and sound, let $C(\F)$ be a circuit of the field $\F$, and let $I$ be an instance. The circuit may or may not have a witness $W$ such that $(I;W)$ is a valid assignment to $C(\F)$. 

If no $W$ exists, $I$ is not part of any word in $L_{C(\F)}$, and there is no way for $P$ to generate a valid assignment. It follows that the verifier will not accept any claimed proof sent by $P$, since the associated $R1CS$ has no solutions for instance $I$. This implies that the system is \term{sound}.

If, on the other hand, $W$ exists and $P$ is honest, $P$ can use its unlimited computational power to compute $W$ and send $(I;W)$ to $V$, which $V$ will accept, since it is a solution to the associated $R1CS$. This implies that the system is \term{complete}.

The system is non-interactive because the prover only sends a single message to the verifier, which contains the proof itself. However the proof system is \term{not} succinct, since the proof is the witness. The proof system is also not zero knowledge, since the verifier has access to the witness and hence learns everything about the witness.
\end{example}
\section{The Fiat Shamir Heuristic}\label{sec:Fiat-Shamir}
In the previous section, we learned that proof systems can be categorized as either interactive or non-interactive. However, in this section, we will explore a specific subset of interactive protocols that can be converted into non-interactive protocols, assuming that the protocol has access to a family of pseudo random functions\footnote{As shown in \cite{chen-20}, there are zero knowledge protocols that can use much simpler function families then pseudo random function families, but we won't delve into this topic any further. The utilization of pseudo random function families was suggested in the the original work of Fiat and Shamir in \cite{fiat-86}}. This transformation enables the non-interactive proof to retain the key security properties of the original interactive version. To date, the most common construction for such a transformation is the so called \term{Fiat-Shamir heuristic} as developed in \cite{fiat-86}. 

To understand the Fiat-Shamir heuristic, observe that interactive protocols can be classified by the number of interactions needed for a prover to convince a verifier. Assuming that the prover must send at least one message to the verifier in any protocol, whether interactive or not, and that for each additional message sent by the prover, the verifier sends one message back, a $k$-move interactive proof system entails the following number of messages:
\begin{equation}
\label{def:k-move-interactive-protocol}
N(m) = 2\cdot k +1
\end{equation}
In this classification, a non-interactive proof system is a $0$-move interactive proof system, where the prover sends precisely one message (the proof) to the verifier. 

\subsection{Sigma Protocols}
In terms of historical significance, $1$-move protocols are particularly noteworthy, in which the verifier's response message is simply a randomly chosen element from a pre-agreed upon response-set. Such systems are known as \term{Sigma Models}, and they were the first systems in which the Fiat-Shamir heuristic was defined.

To provide a more precise definition, let $\Sigma$ be an alphabet, $L$ a formal language defined over $\Sigma$ \ref{sec:formal-languages}, and $\langle I, W\rangle$ a constructive proof for a membership or knowledge claim in $L$ \ref{def:constructive-proof}. Then, a Sigma Model for language $L$ is a $1$-move interactive proof system $(P,V)$ that proceeds through three messages in the following way:
\begin{enumerate}
\label{def_sigma-model}
\item Prover $P$ sends an initial message $m_0$.
\item Verifier $V$ randomly chooses a challenge $c_1\in C$ from a challenge set $C$, and sends it as the second message.
\item Prover $P$ generates a response $m_1$ and sends it as the third and final message.
\end{enumerate}
Finally, the verifier must output either "accept" or "reject" by computing a deterministic function on $I$, as well as the values $m_0$, $c_1$, and $m_1$.
\begin{example}[Schnorr's Protocol: Proof of Knowledge of Discrete Log]
\label{ex:interactive-Schnorr}
One of the simplest and frequently used Sigma protocols, is a proof of knowledge of a discrete logarithm,  due to Schnorr. To see this, let $\G$ be a DL-secure \ref{def:DL-secure} finite cyclic group of prime order $p\in\Prim$ and let $g$ be a generator \ref{cyclic-groups} of $\G$. Given a group element $y\in \G$, the protocol proves knowledge of some $x \in \F_p$, such that $x$ is a discrete logarithm of $y$:
$$
y = g^x
$$
The protocol is zero knowledge in the sense, that the verifier does not learn anything about $x$ besides the fact that the prover knows such an $x$, given $y$.

To see how this problem can be modeled as a Sigma protocol, consider the instance alphabet $\Sigma_I:=\G$ and the witness alphabet $\Sigma_W= \F_p$ together with the following decision function \ref{sec:instance-witness} and its associated language $L_{Schnorr}$ \ref{sec:instance-witness}:
\begin{multline*}
R_{Schnorr} : (\G)^* \times (\F_p)^* \to \{true, false\}\;;\;\\
(<i_1,\ldots,i_n>;<w_1,\ldots, w_m>) \mapsto
\begin{cases}
true & n=1,\; m=1 \text{ and } i_1 = g^{w_1}\\
false & else
\end{cases}
\end{multline*}
Constructive knowledge proofs \ref{def:refined_language} in the language $L_{Schnorr}$ consists of pairs $(i,w)$, where the instance $i$ is an element from the group $\G$ and the witness $w$ is number from the prime field $\F_p$, such that the condition $i=g^w$ holds true.

Given some instance $i$, Schnorr's Sigma protocol provides a way for a prover $P$ and a verifier $V$ to transform any constructive proof of knowledge $(i,w)$ for language $L_{Schnorr}$ into a $1$-move interactive zero knowledge argument of knowledge in the following way:
\begin{enumerate}
\item $P$ chooses a random value $r$ from the scalar field $\F_p$, and sends the initial message $m_0=g^r$. 
\item $V$ responds with a randomly chosen challenge $c_1\in \F^*_p$ from the set of invertible field elements.
\item $P$ sends its response message $m_1=r+w\cdot c_1$.
\end{enumerate}
In this instance, a total of $3=2\cdot 1 + 1$ messages are sent, which are either group elements or field elements. Moreover the challenge set $C$ of this Sigma model consists of all invertible elements in the scalar field of $\G$.

The verifier accepts the proof if $g^{m_1} = m_0\cdot i^{\;c_1}$ and reject the proof otherwise, because the following equivalences are true, if and only if $(i,w)$ is a word in $L_{Schnorr}$, $m_0$ and $m_1$ are computed as expected and $c_1$ is an invertible field element:
\begin{align*}
g^{m_1} =\; & m_0\cdot i^{\;c_1} & \Leftrightarrow\\
g^{r+w\cdot c_1} =\; & g^{r} \cdot i^{\;c_1} &\Leftrightarrow \\
g^r \cdot (g^w)^{c_1} =\; & g^{r} \cdot i^{\;c_1} & \Leftrightarrow \\
g^w =\; & i
\end{align*}
\end{example}
Assuming that a Sigma model has access to a family of pseudo random functions, the \term{Fiat-Shamir heuristic} allows for its transformation into a non-interactive proof system (a $0$-move protocol). The transformation's concept is simple and appealing: using a family of pseudo random functions, the prover can simulate the verifier's response by evaluating an instantiation on the initial message the prover would have sent to the verifier.

To give a more precise definition, assume that $\Sigma$ is an alphabet, $L$ is a formal language defined over $\Sigma$, and $(P,V)$ is a Sigma protocol with challenge set $C$. The Fiat-Shamir heuristic asserts that $(P,V)$ can be transformed into a non-interactive proof system $(P',V')$, provided that there exists a family of pseudo-random functions, parametrized by a seed $s\in\{0,1\}^*$ that maps strings from the set of all messages $\mathtt{Messages}$ onto the set of all challenges $C$:
\begin{equation}
\mathtt{PRF}_s: \mathtt{Messages}^* \to C    
\end{equation}
A frequent problem in Sigma model constructions is the lack of precision in theoretical work regarding the specific data to include in $\mathtt{PRF}_s$. However, understanding what data to absorb into the $\mathtt{PRF}$ is essential for the non-interactive protocol to be as secure as the interactive one. Instead it is often common practice to abstract over the details and simply say that 'all relevant data' should be included into a so called  \term{transcript} of the previous round.

Research, such as in \cite{dao-23} and \cite{bernhard-16}, shows that inadequate transcripts lead to security issues in practical applications. It is therefore crucial to implement the Fiat-Shamir heuristic correctly for real-world use and the basic rule for the transcript is \textit{'to include everything the verifier would know when creating their random challenge.'}

Bernhard and others categorized systems that incorporate not only past messages but also the proof relation, system parameters, and public inputs in the transcript as 'strong Fiat-Shamir transformations.' Those that don't are called 'weak Fiat-Shamir transformations.'

Fortunately, algebraic sponge constructions \ref{def:algebraic-sponge} provide an interface that allows for a clean way to define Fiat Shamir transformations in complex multi-move situations. We therefore won't use the more common but dangerous definition in terms of of \textit{transcripts} and Pseudo Random functions as mostly found in more academic work, but utilize the $\mathtt{Absorb}$ and $\mathtt{Squeeze}$ functions of a sponge directly.

Assuming that $(P,V)$ is a Sigma protocol and that $\langle I, W\rangle$ represents a constructive proof for a membership or knowledge claim in the associated language $L$, the prover $P'$ in the transformed non-interactive system utilizes the prover $P$ of the original system and performs the following steps:
\begin{enumerate}
\label{def_sigma-model-fiat-shamir}
\item $P'$ initializes the sponge and computes $\mathtt{Absorb}(D)$, $\mathtt{Absorb}(L)$ and $\mathtt{Absorb}(I)$ by absorbing a domain separator $D$, a deterministic representation of the language $L$ and the instance $I$ into the sponge.
\item $P'$ computes the initial message $m_0$ using $P$.
\item $P'$ absorbs the initial message into the sponge $\mathtt{Absorb}(m_0)$
\item $P'$ squeezes the simulated challenge $c_1=\mathtt{Squeeze}$.
\item $P'$ computes the response message $m_1$ using $P$ and $c_1$.
\item $P'$ sends the non-interactive proof $\pi=(D,L,I,m_0,m_1)$.
\end{enumerate}
The verifier $V'$ then computes the same sponge state $\mathtt{Absorb}(D)$, $\mathtt{Absorb}(L)$, $\mathtt{Absorb}(I)$ as well as $\mathtt{Absorb}(m_0)$ and squeezes the simulated challenge $c_1=\mathtt{Squeeze}$. It then invokes $V$ to output either "accept" or "reject" by computing a deterministic function on $I$ and the values $m_0$, $c_1$, and $m_1$.


\begin{example}[Fiat-Shamir Heuristics for Schnorr's Protocol]
\label{ex:Schnorr-SNARK}
To given an example of how the Fiat Shamir Heuristic can be used to transform a Sigma protocol into a non interactive proof system, lets look at Shnorr's interactive protocol from example \ref{ex:interactive-Schnorr} again. In this example we will transform an instantiation of the protocol into a non interactive protocol using the strong Fiat Shamir heuristic.  

To instantiate the protocol, we use the large prime order subgroup $\G_1[13]$ of the moon-math-curve $BLS6\_6$ \ref{def:BLS6613} as our prime order group $\G$ together with the scalar field$\F_{13}$ and the generator $g=(13,15)\in \G_1[13]$

To apply the Fiat-Shamir heuristic to this setting, we choose the pen and paper Poseidon sponge for $BLS6\_6$ from \ref{sec:bls-scalar-sponge}. This sponge has two absorb functions: $\textsc{Absorb}_S(x,S)$ that absorbs elements from the $BLS6\_6$ scalar field $\F_{13}$ and the base field sponge $\textsc{Absorb}_B(x,S)$ which safely absorbs elements from the $BLS6\_6$ base field $\F_{43}$. In addition the sponge has a squeeze functions that generates elements from the scalar field $\F_{13}$.

Real world applications often use well known cryptographic sponge constructions like keccak or Poseidon in order to instantiate a Fiat-Shamir PRF. However it is not uncommon to use other cryptographic hash functions like SHA2, in which case care has to be taken to get the implementation details right. 

To compute an example of a non-interactive Shnorr proof, assume that the instance $I=(35,28)$ from $\G_1[13]$ is given. Since $[4](13,15)=(35,28)$ \ref{BLS6-G1-log}, we know that $w=4\in F_{13}$ is a discrete log of $I$ for the generator $g=(13,15)$. 

In order to compute a non-interactive proof of knowledge for the witness $w=4$, the prover $P'$ first initializes the sponge's state by computing
$$
S=[o_1\;||\;i_1]=[0\;||\;0]
$$
The prover then has to decide on a domain separator $D$ and a representation of the language $L$. We arbitrarily choose $D=2 \in \F_{13}$ for the domain separator and we use the generator $g=(13,15)$ as the language representation because the defining equation $y = g ^x$ has $g$ as its only parameter. 

In a next step the prover then has to absorb all these values into the sponge. Since the domain separator is an element of the scalar field we use \ref{bls-6-scalar-sponge} compute
\begin{align*}
S = & [10\cdot (o_1+D)^5 + 8\cdot i_1^5 \;||\; 8\cdot (o_1+D)^5 + 11\cdot i_1^5] \\
  = & [10\cdot (0+2)^5 + 8\cdot 0^5 \;||\; 8\cdot (0+2)^5 + 11\cdot 0^5] \\
  = & [10\cdot 2^5 \;||\; 8\cdot 2^5]
  =  [10\cdot 6 \;||\; 8\cdot 6] \\
  = & [8 \;||\; 9]
\end{align*}  
In order to absorb the representation $(13,15)$ of $L$ into the sponge, we have to apply the base field absorb function to both the $x$ and the $y$ coordinate of this curve point. Using $S=[8 \;||\; 9]$ and \ref{bls-6-base-sponge}, we compute to sponge update for the $x$-coordinate in two steps:
\begin{align*}
S = & [10\cdot (o_1+(\Zdiv{x}{4}))^5 + 8\cdot i_1^5 \;||\; 8\cdot (o_1+(\Zdiv{x}{4}))^5 + 11\cdot i_1^5]\\ 
 = & [10\cdot (8+3)^5 + 8\cdot 9^5 \;||\; 8\cdot (8+3)^5 + 11\cdot 9^5]\\ 
 = & [10\cdot 7 + 8\cdot 3 \;||\; 8\cdot 7 + 11\cdot 3]
 =  [5 + 11 \;||\; 4 + 7]\\ 
 = & [3 \;||\; 11]\\
\\
S = & [10\cdot (o_1+(\Zmod{x}{4}))^5 + 8\cdot i_1^5 \;||\; 8\cdot (o_1+(\Zmod{x}{4}))^5 + 11\cdot i_1^5]\\ 
  = & [10\cdot (3+1)^5 + 8\cdot 11^5 \;||\; 8\cdot (3+1)^5 + 11\cdot 11^5]\\ 
  = & [10\cdot 10 + 8\cdot 7 \;||\; 8\cdot 10 + 11\cdot 7] 
  =  [9 + 4 \;||\; 2 + 12]\\ 
  = & [0 \;||\; 1] 
\end{align*}
After the $x$ coordinate has been absorbed into the sponge we can continue and absorb the $y$-coordinate as well. Then we have to apply the exact same procedure to absorb the instance $I=(35,28)$ into the sponge using the the base field absorb function again. Since the process is clar now we use our sage implementation of the 
$BLS6\_6$ sponge from \ref{bls-6-base-sponge} to first verify the previous computation and to update the sponge:
\begin{sagecommandline}
sage: F43 = GF(43)
sage: S = mm_scalar_sponge_start() # init sponge state
sage: S = mm_scalar_sponge_absorb(F13(2), S)
sage: S
sage: S = mm_base_sponge_absorb(F43(13), S)
sage: S 
sage: S = mm_base_sponge_absorb(F43(15), S)
sage: S = mm_base_sponge_absorb(F43(35), S)
sage: S = mm_base_sponge_absorb(F43(28), S)
sage: S
\end{sagecommandline}
In the next step the non-interactive prover invokes the interactive prover $P$ in order to compute the initial message $m_0=[r](13,15)$ for some random field element $r\in \F_{13}$. We chose $r=3$ and use \ref{BLS6-G1-log} to compute the initial message as
$$
m_0 = [3](13,15) = (38,15)
$$
Instead of sending this message to the verifier as in the interactive protocol, the non-interactive prover first absorbs the message $m_0$ into the sponge and then squeezes a field element $c_1$ from the sponge in order to simulate the verifiers response. Invoking our sage implementation again, we get: 
\begin{sagecommandline}
sage: S = mm_base_sponge_absorb(F43(38), S)
sage: S = mm_base_sponge_absorb(F43(15), S)
sage: c1, S = mm_sponge_squeeze(S)
sage: c1, S
\end{sagecommandline}
The Schnorr protocol requires $c_1$ to be invertible, which in our construction might not happen with some high probability. However in real word applications this probability is usually neglectable as it is in the order of $1/2^{256}$.

The non-interactive prover invokes the interactive prover $P$ again in order to compute the simulated initial response message $m_1=r+w\cdot c_1= 3+4\cdot 12 = 12$. It then sends the following non-interactive proof to the verifier:
$$
\pi = (D,L,I,m_0,m_1) = (2, (13,15) , (35,28), (38,15), 12)
$$
So while the interactive protocol requires three messages to be send, this non-interactive protocol sends a single message only.

Since the sponge construction is deterministic, the verifier can use $D$, $L$, $I$ and $m_0$ from the proof $\pi$ in order to compute the exact same challange $c_1=12$ in order to invoke the interactive verifier $V$, which accepts the proof if $g^{m_1} = m_0\cdot i^{\;c_1}$ and reject the proof otherwise.
\end{example}
\begin{exercise} Consider the group $\G_1[13]$ as in the previous example and the instance $I=(13,28)$. Compute a witness $W$ for $I$ and a non-interactive zero knowledge proof of knowledge for $I$ using the Schnorr protocol and the $BLS6\_6$ sponge. 
\end{exercise}
\subsection{Multi-move Sigma Protocols}
While $1$-move interactive proof systems like Sigma protocols are traditional targets for the Fiat Shamir Heuristic, the same approach can be generalized to certain $k$-move interactive proof systems, providing the verifier is required to send challenges as random elements from some agreed on challenge set only. We call those proof systems \term{$k$-move Sigma protocols}. While $1$-move Sigma models essential preserve the security guarantees of the interactive system, care must be taken regarding the security of the transformed non-interactive protocols, as the security is generally expected to be lower then the security of the interactive proof system (See \cite{attema-21} for an analysis). 

To provide a more precise definition, let $\mathtt{Sponge}$ be a sponge construction \ref{def:algebraic-sponge}, $\Sigma$ be an alphabet, $L$ a formal language defined over $\Sigma$ \ref{sec:formal-languages}, and $\langle I, W\rangle$ a constructive proof for a membership or knowledge claim in $L$ \ref{def:constructive-proof}. Then the generalized Fiat-Shamir heuristic transforms any $k$-move Sigma model $(P,V)$ into a non-interactive proof system $(P',V')$ in the following way:
\begin{enumerate}
\label{def_sigma-model-fiat-shamir}
\item $P'$ initializes the sponge and computes $\mathtt{Absorb}(D)$, $\mathtt{Absorb}(L)$ and $\mathtt{Absorb}(I)$ by absorbing a domain separator $D$, a deterministic representation of the language $L$ and the instance $I$ into the sponge.
\item $P'$ computes the initial message $m_0$ using $P$.
\item $P'$ absorbs the initial message into the sponge $\mathtt{Absorb(m_0)}$
\item $P'$ squeezes the first simulated challenge $c_1=\mathtt{Squeeze}$ from the sponge.
\item $P'$ computes the first response message $m_1$ using $c_1$ and $P$.
\item $P'$ absorbs the first message into the sponge $\mathtt{Absorb(m_1)}$
\item $P'$ squeezes the second simulated challenge $c_2=\mathtt{Squeeze}$ from the sponge.
\item $P'$ computes the second response message $m_2$ using $c_2$ and $P$.
\item $\vdots$
\item $P'$ computes the $k$-th response message $m_{k}$ using $c_k$ and $P$.
\item $P'$ sends the non-interactive proof $\pi=(D,L,I, m_0,m_1,\ldots,m_{k})$.
\end{enumerate}
The verifier $V'$ follows the same pattern of absorption and squeezing then the prover using the data from $\pi$, after that it invokes $V$ to output either "accept" or "reject" by computing a deterministic function on $I$ and the values $m_i$, and $c_i$.



\section{The ``Groth16'' Protocol}
\label{sec:gorth_16}
 In \chaptname{} \ref{chap:statements}, we presented algebraic circuits, their associated Rank-1 Constraint Systems and their induced Quadratic Arithmetic Programs. These models define formal languages, and associated memberships and knowledge claims provide constructive proofs by executing the circuit to compute a solution to the associated R1CS. As previously noted in Section \ref{sec:QAP} the proof can then be transformed into a polynomial that is only divisible by another polynomial if and only if the proof is valid. 
 
In \cite{Groth16}, Jens Groth developed a method for transforming constructive proofs into zero-knowledge succinct non-interactive arguments of knowledge. Given groups $\G_1$, $\G_2$, and $\G_3$, and an efficiently computable pairing map $e(\cdot,\cdot): \G_1 \times \G_2 \to \G_3$ (see \ref{pairing-map}), the resulting zk-SNARK in Groth's protocol is of constant size, consisting of two elements from $\G_1$ and one element from $\G_2$, regardless of the instance and witness size. Verification is non-interactive, requiring the computation of a number of exponentiations proportional to the instance size, along with three group pairings, in order to verify a single proof.

The generated zk-SNARK is zero-knowledge, has completeness and soundness in the generic bilinear group model, under the assumption of the existence of a trusted third party that executes a preprocessing phase to produce a Common Reference String and a simulation trapdoor. It is imperative that this party is trusted to delete the simulation trapdoor, as any individual in possession of it would have the ability to simulate proofs. As demonstrated in \cite{bowe-17}, it is possible to transform the single-party trusted setup into a multi-party computation that is secure as long as at least one contributor deletes their contribution to the simulation trapdoor. 

To be more precise, let $R$ be a Rank-1 Constraint System defined over some finite field $\F_r$. Then \term{Groth\_16 parameters} for $R$ are given by the following set:
\begin{equation}
\label{groth16-parameters}
\mathtt{Groth\_16-Param}(R)=(r, \G_1, \G_2, e(\cdot,\cdot), g_1,g_2)
\end{equation}

Here, $\G_1$ and $\G_2$ are finite cyclic groups of order $r$, $g_1$ is a generator of $\G_1$, $g_2$ is a generator of $\G_2$ and $e: \G_1 \times \G_2 \to \G_T$ is an efficiently computable, non-degenerate, bilinear pairing for some target group $\G_T$. In real-world applications, the parameter set is usually agreed on in advance. 

Given some Groth\_16 parameters, a \term{Groth\_16 protocol} is then a quadruple of probabilistic polynomial algorithms $(\textsc{Setup},\textsc{Prove},\textsc{Vfy},\textsc{Sim})$ such that the following conditions hold:
\begin{itemize}
\item (Setup-Phase): $(CRS,\Tau)\leftarrow \textsc{Setup}(R)$: Algorithm $\textsc{Setup}$ takes the R1CS $R$ as input and computes a \term{\concept{Common Reference String}} $CRS$ and a \term{simulation trapdoor} $\Tau$.
\item (Prover-Phase): $\pi\leftarrow \textsc{Prove}(R,CRS,I,W)$: Given a constructive proof $(I;W)$ for $R$, algorithm $\textsc{Prove}$ takes the R1CS $R$, the \concept{Common Reference String} $CRS$ and the constructive proof $(I,W)$ as input and computes an zk-SNARK $\pi$.
\item (Verifier Phase): $\{\mathtt{accept},\mathtt{reject}\}\leftarrow \textsc{Vfy}(R,CRS,I,\pi)$:   Algorithm \textsc{Vfy} takes the R1CS $R$, the \concept{Common Reference String} $CRS$, the instance $I$ and the zk-SNARK $\pi$ as input and returns \texttt{reject} or \texttt{accept}.
\item (Proof Simulation): $\pi\leftarrow \textsc{Sim}(R,\tau,CRS, I)$: Algorithm \textsc{Sim} takes the R1CS $R$, the \concept{Common Reference String} $CRS$, the simulation trapdoor $\Tau$ and the instance $I$ as input and returns a zk-SNARK $\pi$. 
\end{itemize}
We will explain these algorithms together with detailed examples in the remainder of this section.

Assuming a trusted third party or the presence of a corresponding multi-party computation for the setup, the protocol is capable of deriving a zk-SNARK from a constructive proof for $R$, provided that the group order $r$ being larger than the number of constraints in the associated R1CS.

\begin{example}[The 3-Factorization Problem]
\label{ex:3-fac-groth-16-params} Consider the $3$-factorization problem from \ref{ex:3-factorization} and its associated algebraic circuit \ref{ex:3-fac-zk-circuit} as well the Rank-1 Constraint System from \ref{ex:3-factorization-r1cs}. In this example, we want to agree on a parameter set $(r, \G_1, \G_2, e(\cdot,\cdot), g_1, g_2)$ in order to use the Groth\_16 protocol for our $3$-factorization problem. 

To find proper parameters, first observe that the circuit \ref{ex:3-fac-zk-circuit}, as well as its associated R1CS $R_{3.fac\_zk}$ \ref{ex:3-factorization-r1cs} and the derived QAP \ref{ex:3-fac-QAP}, are defined over the field $\F_{13}$. We therefore have to choose pairing groups $\G_1$ and $\G_2$ of order $13$. 

We know from \ref{BLS6} that the moon-math curve \texttt{BLS6\_6} has two subgroups $\G_1[13]$ and $\G_2[13]$, which are both of order $13$. The associated Weil pairing $e(\cdot,\cdot)$ \ref{BLS6-weil-pairing} is efficiently computable, bilinear as well as non-degenerate. We therefore choose those groups and the Weil pairing together with the generators $g_1 = (13,15) $ and $g_2=(7v^2,16v^3)$ of $\G_1[13]$ and $\G_2[13]$, as a parameter set:
$$
\mathtt{Groth\_16-Param}(R_{3.fac\_zk})=(13, \G_1[13], \G_2[13], e(\cdot,\cdot), (13,15),(7v^2,16v^3))
$$
It should be noted that our choice is not unique. Every pair of finite cyclic groups of order $13$ that has an efficiently computable, non-degenerate, bilinear pairing qualifies as a Groth\_16 parameter set. The situation is similar to real-world applications, where SNARKs with equivalent behavior are defined over different curves, used in different applications.
\end{example}
\begin{example}[The 3-Factorization Problem in Circom and Snarkjs]
\label{ex:3-fac-groth-16-params-circom} Snark.js is a JavaScript library that facilitates the development of systems incorporating zero-knowledge proofs (ZKPs), including the Groth-16 protocol. To showcase a practical example of the 3-factorization problem, we utilize our Circom implementation (see \ref{ex:3-fac-circom}), which compiles into a form that is compatible with snark.js.

As of the time of writing, Snark.js supports the elliptic curves \curvename{alt\_bn128}, \curvename{BLS12-381}, and \curvename{Goldilocks}. For the purposes of this example, we shall utilize \curvename{alt\_bn128}, and it's associated scalar field $\F_{bn128}$ as introduced in \ref{BN128}. The Groth-16 parameters for this curve, as officially defined for the Ethereum blockchain, can be found in \href{https://github.com/ethereum/EIPs/blob/master/EIPS/eip-197.md}{EIP-197}. Snark.js utilizes those parameters.
\end{example}
\begin{exercise}
\label{ex:baby-jubjub-circom} Implement the \href{https://github.com/iden3/iden3-docs/blob/master/source/iden3_repos/research/publications/zkproof-standards-workshop-2/baby-jubjub/baby-jubjub.rst}{Baby-JubJub}  twisted Edwards curve equation in Circom and compile it into an R1CS and associated witness generator.
\end{exercise}

\subsection{The Setup Phase} Generating zk-SNARKs from constructive proofs in the Groth16 protocol requires a preprocessing phase to be performed. This phase must be executed once for every Rank-1 Constraint System and its associated Quadratic Arithmetic Program. The outcome of this phase is a \concept{Common Reference String}, which is necessary for both the prover and the verifier to generate and verify the zk-SNARK. Additionally, a simulation trapdoor is generated during this phase, which can be utilized to simulate proofs.

To be more precise, let $L$ be a language defined by some Rank-1 Constraint System $R$ such that  a constructive proof of knowledge for an instance $<I_1,\ldots,I_n>$ in $L$ consists of a witness $<W_1,\ldots,W_m>$. Let $QAP(R) = \left\{T\in \F[x],\left\{A_j,B_j,C_j\in \F[x]\right\}_{j=0}^{n+m}\right\}$ be a Quadratic Arithmetic Program associated to $R$, and let $\{\G_1, \G_2, e(\cdot,\cdot), g_1, g_2, \F_r\}$ be a set of Groth\_16 parameters.

The setup phase then samples $5$ random, invertible elements $\alpha$, $\beta$,$\gamma$, $\delta$ and $\tau$ from the scalar field $\F_r$ of the protocol and outputs the \term{simulation trapdoor} $\Tau$:
\begin{equation}
\label{def:groth16-trapdoor}
\Tau = (\alpha, \beta, \gamma, \delta, \tau)
\end{equation}
In addition, the setup phase uses those $5$ random elements together with the two generators $g_1$ and $g_2$  and the Quadratic Arithmetic Program to generate a \term{\concept{Common Reference String}} $CRS_{QAP}= (CRS_{\mathbb{G}_1},CRS_{\mathbb{G}_2})$ of language $L$:

\begin{definition}[\deftitle{Common \concept{reference string}}]
\begin{align*}
\label{def:groth16-crs}
CRS_{\mathbb{G}_{1}} &= \textstyle\left\{ \begin{array}{c}
g_1^\alpha,g_1^\beta,g_1^\delta,\left(g_1^{\tau^j},\ldots\right)_{j=0}^{deg(T)-1},
\left(g_1^{\frac{\beta\cdot A_{j}(\tau)+\alpha\cdot B_{j}(\tau)+C_{j}(\tau)}{\gamma}},\ldots\right)_{j=0}^n\\
\left(g_1^{\frac{\beta\cdot A_{j+n}(\tau)+\alpha\cdot B_{j+n}(\tau)+C_{j+n}(\tau)}{\delta}},\ldots\right)_{j=1}^m,\left(g_1^{\frac{\tau^{j}\cdot T(\tau)}{\delta}},\ldots\right)_{j=0}^{deg(T)-2}
\end{array}\right\} \\
CRS_{\mathbb{G}_{2}} &= \left\{g_2^\beta ,g_2^\gamma,g_2^\delta,\left(g_2^{\tau^j},\ldots\right) _{j=0}^{deg(T)-1}\right\}
\end{align*}
\end{definition}

Common \concept{reference string}s depend on the simulation trapdoor, and are therefore not unique to the problem. Any language can have more than one \concept{Common Reference String}. The  size of a \concept{Common Reference String} is linear in the size of the instance and the size of the witness.

If a simulation trapdoor $\Tau = (\alpha,\beta,\gamma,\delta, \tau)$ is given, we call the element $\tau$ a \term{secret evaluation point} of the protocol, because if $\F_r$ is the scalar field of the finite cyclic groups $\G_1$ and $\G_2$, then a key feature of any \concept{Common Reference String} is that it provides data to compute the evaluation of any polynomial $P\in \F_r[x]$ of degree $deg(P)<deg(T)$ at the point $\tau$ in the exponent of the generator $g_1$ or $g_2$, without knowing $\tau$.

To be more precise, let $\tau$ be the secret evaluation point and let $P(x)=a_0\cdot x^0 + a_1\cdot x^1 + \ldots a_k\cdot x^k$ be a polynomial of degree $k<deg(T)$ with coefficients in $\F_r$. Then we can compute $g_1^{P(\tau)}$ without knowing what the actual value of $\tau$ is:

\label{eq:exp_evaluation-poly}
\begin{align}
g_1^{P(\tau)} & = g_1^{a_0\cdot \tau^0 + a_1\cdot \tau^1 + \ldots a_k\cdot \tau^k} \notag\\
 & = g_1^{a_0\cdot \tau^0} \cdot g_1^{a_1\cdot \tau^1} \cdot \ldots \cdot g_1^{a_k\cdot \tau^k}\notag\\
 & = \Big(g_1^{\tau^0}\Big)^{a_0} \cdot \Big(g_1^{\tau^1}\Big)^{a_1} \cdot \ldots \cdot \Big(g_1^{\tau^k}\Big)^{a_k}
\end{align}
In this expression, all group points $g_1^{\tau^j}$ are part of the \concept{Common Reference String}, hence, they can be used to compute the result. The same holds true for the evaluation of $g_2^{P(\tau)}$, since the $\G_2$ part of the \concept{Common Reference String} contains the points $g_2^{\tau^j}$. 

In practical applications, the elements $g_{1/2}^{\tau^0}$, $g_{1/2}^{\tau^1}$, $\ldots$, $g_{1/2}^{\tau^k}$ are commonly referred to as the \term{powers of tau}, a term frequently used in trusted setup computations. Additionally, the simulation trapdoor is often referred to as the \term{toxic waste} of the setup phase. As will be demonstrated in section \ref{sec:proof_simulation}, the simulation trapdoor can be utilized to generate fraud proofs, which are verifiable zk-SNARKs that can be constructed without knowledge of any witness. The Common Reference String is also known as the \term{prover and verifier key pair}.

To ensure the security of the protocol, the setup must be carried out in a way that ensures the safe disposal of the simulation trapdoor. The simplest method for accomplishing this is through the use of a so-called \term{trusted third party}, where trust is placed in the party to properly generate the \concept{Common Reference String} and securely dispose of the toxic waste afterwards.

However, finding a trusted third party can be challenging, thus alternative methods have been developed in practical applications. These utilize multi-party computation in the setup phase, which can be publicly verified for proper execution, and the simulation trapdoor is not recoverable if at least one participant destroys their contribution. Each participant holds only a fraction of the trapdoor, making it recoverable only if all participants collaborate and share their parts.

\begin{example}[The $3$-factorization Problem]
To see how the setup phase of a Groth\_16 zk-SNARK can be computed, consider the $3$-factorization problem from \ref{ex:3-factorization} and the Groth\_16 parameters from \examplename{} \ref{ex:3-fac-groth-16-params}. As we have seen in \ref{ex:3-fac-QAP}, an associated Quadratic Arithmetic Program is given by the following set:
\begin{multline*}
QAP(R_{3.fac\_zk}) =\{x^{2}+x+9,\\
 \{0,0,6x+10,0,0,7x+4\},\{0,0,0,6x+10,7x+4,0\},\{0,7x+4,0,0,0,6x+10\}\}
\end{multline*}
To transform this QAP into a \concept{Common Reference String}, we choose the  field elements $\alpha=6$, $\beta=5$, $\gamma=4$, $\delta=3$, $\tau=2$ from $\mathbb{F}_{13}$. 
In real-world applications, it is important to sample those values randomly from the scalar field, but in our approach, we choose those non-random values to make them more memorizable, which helps in pen-and-paper computations. Our simulation trapdoor is then given as follows:
$$
\Tau = (6,5,4,3,2)
$$

We keep this secret in order to simulate proofs later on, but we are careful to hide $\Tau$ from anyone who hasn't read this book. Then we instantiate the \concept{Common Reference String} \ref{def:groth16-crs}from those values. Since our groups are subgroups of the \texttt{BLS6\_6} elliptic curve, we use scalar product notation instead of exponentiation. 

To compute the $\G_1$ part of the \concept{Common Reference String}, we use the logarithmic order of the group $\G_1$ \ref{BLS6-G1-log}, the generator $g_1=(13,15)$, as well as the values from the simulation trapdoor. Since $deg(T)=2$, we get the following:
\begin{align*}
[\alpha]g_1 & = [6](13,15) = (27,34) \\
[\beta]g_1 & = [5](13,15) = (26,34) \\
[\delta]g_1 & = [3](13,15) = (38,15)
\end{align*}
To compute the rest of the $\G_1$ part of the \concept{Common Reference String}, we expand the indexed tuples and insert the secret random elements from the simulation backdoor. We get the following:
\begin{align*}
\Big( [\tau^{j}]g_1,\ldots\Big) _{j=0}^{1} = 
 & \Big( [2^0](13,15), [2^1](13,15)\Big)  \\
 = & \Big((13,15),(33,34)\Big)\\
\Big([\frac{\beta A_{j}(\tau)+ \alpha B_{j}(\tau) + C_{j}(\tau)}{\gamma}]g_1,\ldots\Big)_{j=0}^1 =
 & \Big([\frac{5 A_{0}(2)+6 B_{0}(2)+C_{0}(2)}{4}](13,15),\\
 &\phantom{\Big(} [\frac{5 A_{1}(2)+6 B_{1}(2)+C_{1}(2)}{4}](13,15)\Big)\\
\Big([\frac{\beta A_{j+n}(\tau)+ \alpha B_{j+n}(\tau) + C_{j+n}(\tau)}{\delta}]g_1,\ldots\Big)_{j=1}^4 = 
&  \Big( [\frac{5 A_{2}(2)+ 6 B_{2}(2) + C_{2}(2)}{3}](13,15),\\ 
& \phantom{\Big(} [\frac{5 A_{3}(2)+ 6 B_{3}(2) + C_{3}(2)}{3}](13,15),\\
& \phantom{\Big(} [\frac{5 A_{4}(2)+ 6 B_{4}(2) + C_{4}(2)}{3}](13,15),\\ 
& \phantom{\Big(} [\frac{5 A_{5}(2)+ 6 B_{5}(2) + C_{5}(2)}{3}](13,15)\Big)\\
\Big([\frac{\tau^j\cdot T(\tau)}{\delta})]g_1\Big)_{j=0}^0 = & \Big([\frac{2^0\cdot T(2)}{3}](13,15)\Big) 
\end{align*}
To compute the curve points on the right side of these expressions, we need the polynomials from the associated Quadratic Arithmetic Program and evaluate them on the secret point $\tau=2$. Since $4^{-1}=10$ and $3^{-1}=9$ in $\F_{13}$, we get the following:
\begin{align*}
[\frac{5 A_{0}(2)+6 B_{0}(2)+C_{0}(2)}{4}](13,15) = 
 & [(5 \cdot 0 +6\cdot 0 + 0)\cdot 10](13,15) = [0](13,14)\\
 & \mathcal{O} \\
[\frac{5 A_{1}(2)+6 B_{1}(2)+C_{1}(2)}{4}](13,15) = 
 & [(5\cdot 0 +6\cdot 0 + (7\cdot 2 + 4))\cdot 10](13,15) = [11](13,15) = \\
 & (33,9) \\
[\frac{5 A_{2}(2)+ 6 B_{2}(2) + C_{2}(2)}{3}](13,15) =
 & [(5\cdot (6\cdot 2 +10) +6\cdot 0 +0 )\cdot 9](13,15) = [2](13,15) = \\
 & (33,34) \\
[\frac{5 A_{3}(2)+ 6 B_{3}(2) + C_{3}(2)}{3}](13,15) =
 & [(5\cdot 0 +6\cdot (6\cdot 2 + 10) + 0 )\cdot 9](13,15) = [5](13,15) = \\
 & (26,34) \\
[\frac{5 A_{4}(2)+ 6 B_{4}(2) + C_{4}(2)}{3}](13,15) = 
 & [(5\cdot 0+6\cdot(7\cdot 2 +4)+0)\cdot 9](13,15) =[10](13,15) = \\
 & (38,28) \\
[\frac{5 A_{5}(2)+ 6 B_{5}(2) + C_{5}(2)}{3}](13,15) =
 & [(5\cdot (7\cdot 2 + 4) +6\cdot 0 + 6\cdot 2 + 10 )\cdot 9](13,15) = [7](13,15) = \\
 & (27,9)\\
[\frac{2^0\cdot T(2)}{3}](13,15) =
 & [1\cdot (2^2+2+9)\cdot 9](13,15)= [5](13,15) = \\
 & (26,34)
\end{align*}
Putting all those values together, we see that the $\mathbb{G}_1$ part of the \concept{Common Reference String} is given by the following set of $12$ points from the \texttt{BLS6\_6} $13$-torsion group $\G_1$: 
\begin{equation}
\label{ex:3-fac-groth-16-crs}
CRS_{\mathbb{G}_{1}}=\left\{ \begin{array}{c}
(27,34),(26,34),(38,15),\Big((13,15),(33,34)\Big),
\Big(\mathcal{O}, (33,9)\Big)\\
\Big((33,34),(26,34),(38,28),(27,9)\Big),
\Big((26,34)\Big)
\end{array}\right\}
\end{equation}

To compute the $\G_2$ part of the \concept{Common Reference String}, we use the logarithmic order of the group $\G_2$ \ref{BLS6-G2-log}, the generator $g_2=(7v^2,16v^3)$, as well as the values from the simulation trapdoor. Since $deg(T)=2$, we get the following:
\begin{align*}
[\beta]g_2 & = [5](7v^2,16v^3) = (16v^2,28v^3) \\
[\gamma]g_2 & = [4](7v^2,16v^3) = (37v^2,27v^3) \\
[\delta]g_2 & = [3](7v^2,16v^3) = (42v^2,16v^3)
\end{align*}
To compute the rest of the $\G_2$ part of the \concept{Common Reference String}, we expand the indexed tuple and insert the secret random elements from the simulation trapdoor. We get the following:
\begin{align*}
\Big( [\tau^{j}]g_2,\ldots\Big) _{j=0}^{1} = 
 & \Big( [2^0](7v^2,16v^3), [2^1](7v^2,16v^3)\Big)  \\
 = & \Big((7v^2,16v^3),(10v^2,28v^3)\Big)
\end{align*}
Putting all these values together, we see that the $\mathbb{G}_2$ part of the \concept{Common Reference String} is given by the following set of $5$ points from the \texttt{BLS6\_6} $13$-torsion group $\G_2$:
$$
CRS_{\mathbb{G}_{2}}=\left\{(16v^2,28v^3) ,(37v^2,27v^3),(42v^2,16v^3),\Big(7v^2,16v^3), (10v^2,28v^3)\Big)\right\} 
$$
Given the simulation trapdoor $\Tau$ and the Quadratic Arithmetic Program \ref{ex:3-fac-QAP}, the associated \concept{Common Reference String} of the $3$-factorization problem is as follows:
\begin{align*}
CRS_{\mathbb{G}_{1}} &=\left\{ \begin{array}{c}
(27,34),(26,34),(38,15),\Big((13,15),(33,34)\Big),
\Big(\mathcal{O}, (33,9)\Big)\\
\Big((33,34),(26,34),(38,28),(35,28)\Big),
\Big((26,34)\Big)
\end{array}\right\}\\
CRS_{\mathbb{G}_{2}} &=\left\{(16v^2,28v^3) ,(37v^2,27v^3),(42v^2,16v^3),\Big(7v^2,16v^3), (10v^2,28v^3)\Big)\right\}
\end{align*}
We then publish this data to everyone who wants to participate in the generation of a zk-SNARK or its verification in the $3$-factorization problem.

To understand how this \concept{Common Reference String} can be used to evaluate polynomials at the secret evaluation point in the exponent of a generator, let's assume that we have deleted the simulation trapdoor. In that case, assuming that the discrete logarithm problem is hard in our groups, we have no way to know the secret evaluation point anymore, hence, we cannot evaluate polynomials at that point. However, we can evaluate polynomials of smaller degree than the degree of the target polynomial in the exponent of both generators at that point. 

To see that, consider e.g. the polynomials $A_2(x)= 6x +10$ and $A_5(x)=7x+4$ from the QAP of this problem. To evaluate these polynomials in the exponent of $g_1$ and $g_2$ at the secret point $\tau$ without knowing the value of $\tau$ (which is $2$ in our case), we can use the \concept{Common Reference String} and equation \ref{eq:exp_evaluation-poly}. Using the scalar product notation instead of exponentiation, we get the following:
\begin{align*}
[A_2(\tau)]g_1 & = [6\cdot \tau^1 + 10\cdot \tau^0] g_1 \\
     & = [6](33,34) + [10](13,15) & \text{\# } [\tau^0]g_1 = (13,15), [\tau^1]g_1 = (33,34)\\
     & = [6\cdot 2](13,15) + [10](13,15) = [9](13,15) & \text{\# logarithmic order on } \G_1 \\   
     & = (35,15)\\
[A_5(\tau)]g_1 & = [7\cdot \tau^1 + 4\cdot \tau^0] g_1 \\
     & = [7](33,34) + [4](13,15) \\
     & = [7\cdot 2](13,15) + [4](13,15) = [5](13,15)\\
     & = (26,34)     
\end{align*}

Indeed, we are able to evaluate the polynomials in the exponent at a secret evaluation point, because that point is encrypted in the curve point $(33,34)$ and its secrecy is protected by the discrete logarithm assumption. Of course, in our computation, we recovered the secret point $\tau=2$, but that was only possible because we know the logarithmic order of our groups with respect to the generators. Such an order is infeasible in cryptographically secure curves. We can do the same computation on $\G_2$ and get the following:
\begin{align*}
[A_2(\tau)]g_2 & = [6\cdot \tau^1 + 10\cdot \tau^0] g_2 \\
     & = [6](10v^2,28v^3) + [10](7v^2,16v^3) \\
     & = [6\cdot 2](7v^2,16v^3) + [10](7v^2,16v^3) = [9](7v^2,16v^3) \\   
     & = (37v^2,16v^3)\\
[A_5(\tau)]g_2 & = [7\cdot \tau^1 + 4\cdot \tau^0] g_1 \\
     & = [7](10v^2,28v^3) + [4](7v^2,16v^3) \\
     & = [7\cdot 2](7v^2,16v^3) + [4](7v^2,16v^3) = [5](7v^2,16v^3)\\
     & = (16v^2,28v^3)     
\end{align*}

Apart from the target polynomial $T$, all other polynomials of the Quadratic Arithmetic Program can be evaluated in the exponent this way.
\end{example}

\begin{example}[The 3-Factorization Problem in Circom and Snark.js]
\label{ex:3-fac-groth-16-setup-circom} The implementation of the Groth\_16 zk-SNARK setup phase in real world applications can be observed through the examination of our Circom implementation of the $3$-factorization problem \ref{ex:3-fac-circom} and the associated parameter set from Snark.js, as outlined in example \ref{ex:3-fac-groth-16-params-circom}.

In accordance with the methodology described in \cite{bowe-17}, the generation of the Common Reference String in Snark.js is comprised of two parts. The first part depends on an upper bound on the number of constraints in the circuit, while the second part is dependent on the circuit itself. This division increases the flexibility of the trusted setup procedure, as protocols with Universal Common Reference Strings, such as PLONK, only require the execution of the first phase, while the Groth\_16 protocol mandates the execution of both phases.

The first phase, commonly referred to as \term{the powers of tau}, involves the calculation of consecutive powers, $g^\tau$, $g^{\tau^2}$, $g^{\tau^3}$, $\ldots$, $g^{\tau^k}$, of a random field element $\tau$ within the exponents of agreed-upon generators of $\G_1$ and $\G_2$. The random element $\tau$ can either be provided by a trusted third party or generated through a multi-party computation.

Assuming that an upper bound on the number of constraints in Circom's 3-fac circuit is given by $2^4$, the first part is initialized as follows:
\\
\\
\texttt{:\$ snarkjs powersoftau new bn128 4 pot4\_0000.ptau -v}
\\
\\
The \texttt{new} command is used to start a new phase and the first parameter after \texttt{new} refers to the type of curve and hence specifies the Groth-16 parameter set as defined in \ref{ex:3-fac-groth-16-params-circom}. The next parameter \texttt{a}, in this case 4, defines an upper bound $2^a$ on the number of constraints that the setup can accept. 

After this initialization, it is possible for multiple parties to contribute randomness to the common reference string:
\\
\\
\texttt{:\$ snarkjs powersoftau contribute pot4\_0000.ptau pot4\_0001.ptau \\--name="1st\_cont" -v}
\\
\\
This step can be repeated and the contribution of randomness by each party to the common reference string is facilitated by the creation of a new contribution file, and the user is prompted to input additional entropy. It has been demonstrated that, provided at least one contributor forgets their randomness, recovery of the simulation trapdoor defined in reference \ref{def:groth16-trapdoor} is impossible. Verification of the validity of any contribution file is performed as follows:
\\
\\
\texttt{:\$ snarkjs powersoftau verify pot4\_0001.ptau}
\\
\\
The completion of the first phase requires the incorporation of some public and unpredictable randomness into the powers of tau generation, which needs to be unpredictable until the contribution from the final participant is made. This is typically achieved through the use of the hash of the latest block in a publicly accessible blockchain, or a similar mechanism.
\\
\\
\texttt{:\$ snarkjs powersoftau beacon pot4\_0001.ptau pot4\_beacon.ptau \\ 0102030405060708090a0b0c00 10 -n="Final Beacon"}
\\
\\
Upon the incorporation of the contribution of randomness from the participating parties and the random beacon, the following two commands serve to complete and validate the first phase:
\\
\\
\texttt{:\$ snarkjs powersoftau prepare phase2 pot4\_beacon.ptau \\ pot4\_final.ptau -v}\\
\texttt{:\$ snarkjs powersoftau verify pot4\_final.ptau}
\\
\\
It is apparent that this phase only depends on the upper bound of the number of constraints and is independent of any specific circuit. Therefore, this power of tau ceremony can be utilized to generate a common reference string for any circuit with a number of constraints less than $2^4$.

As indicated in reference \ref{ex:3-fac-circom}, the three\_fac circuit in Circom consists of two constraints. Hence, the randomness generated from this power of tau ceremony can be employed to initiate the second phase of the Common Reference String generation process:
\\
\\
\texttt{:\$ snarkjs groth16 setup three\_fac.r1cs pot4\_final.ptau \\ three\_fac0000.zkey}
\\
\\
The second phase commences with the computation of a Groth\_16 Common Reference String, as specified in reference \ref{def:groth16-crs}. This phase depends on the R1CS of the problem, and the resulting computation is saved to \fname{three\_fac0000.zkey}.

In contrast to the first phase, where the randomness was used to generate the '$\tau$' parameter of the CRS, multiple parties can now contribute randomness to the other parameters, namely $\alpha$, $\beta$, $\gamma$, and $\delta$, of the Groth\_16 CRS.
\\
\\
\texttt{:\$ snarkjs zkey contribute three\_fac0000.zkey \\ three\_fac0001.zkey --name="1st Contributor Name" -v}
\\
\\
This  creates a file with a new contribution to the second phase and prompts the user to provide additional randomness to enhance entropy. This step can be repeated many times for different users. The correctness of any contribution file can be verified as follows:
\\
\\
\texttt{:\$ snarkjs zkey verify three\_fac.r1cs pot4\_final.ptau \\ three\_fac0001.zkey}
\\
\\
The second phase requires the integration of unpredictable, public randomness, which is not known prior to the contribution of the final participant. This can be achieved through the utilization of a method such as the hash of the latest block in a public blockchain.:
\\
\\
\texttt{:\$ snarkjs zkey beacon three\_fac0001.zkey three\_fac\_final.zkey \\
010203040506070809 10 -n="Final Beacon phase2"}
\\
\\
Once the randomness input from all parties and the random beacon have been incorporated, the verification of the second phase can be performed using the following two commands. This process will also export the verification key, which is a vital component of the Common Reference String and will be stored in a JSON file for the verifier to use: 
\\
\\
\texttt{:\$ snarkjs zkey verify three\_fac.r1cs pot4\_final.ptau \\ three\_fac\_final.zkey}\\
\texttt{:\$ snarkjs zkey export verificationkey three\_fac\_final.zkey \\ verification\_key.json}
\\
\\
The Circom trusted setup therefore enables the creation of the Common Reference String \fname{three\_fac\_final.zkey}, which holds both the prover and the verifier key. The verifier key can also be exported as a JSON file \fname{verification\_key.json} for the purpose of publishing it on a public blockchain for implementation as a smart contract.
\end{example}
\begin{exercise} 
\label{ex:baby-jubjub-circom-setupt}
Consider exercise \ref{ex:baby-jubjub-circom} and execute a 3-party trusted setup phase for the baby-jubjub circuit.
\end{exercise}

\subsection{The Prover Phase} Given some Rank-1 Constraint System $R$ and instance $I=<I_1,\ldots, I_n>$, the objective of the prover phase is to convince any verifier that the prover knows a witness $W$ to instance $I$ such that  $(I;W)$ is a word in the language $L_R$ of the system, without revealing anything about $W$. 

To achieve this in the Groth\_16 protocol, we assume that any prover has access to the Rank-1 Constraint System of the problem, in addition to some algorithm that tells the prover how to compute constructive proofs for the R1CS. In addition, the prover has access to a \concept{Common Reference String} and its associated Quadratic Arithmetic Program. 

To create a zk-SNARK for the given instance, the prover begins by computing a valid constructive proof, as outlined in reference \ref{r1cs-constructive-proofs}. This involves producing a suitable witness $W=<W_1,\ldots,W_m>$ such that $(<I_1,\ldots, I_n>; <W_1,\ldots,W_m>)$ is a valid solution to the Rank-1 Constraint System $R$. 

After generating the witness, the prover employs the Quadratic Arithmetic Program to compute the polynomial $P_{(I;W)}$, as outlined in reference \ref{polynomial-P-IW}. The prover then divides this polynomial by the target polynomial $T$ of the Quadratic Arithmetic Program. As $P_{(I;W)}$ is derived from a valid solution to the R1CS, as stated in reference \ref{polynomial-P-IW}, it follows that $P_{(I;W)}$ is divisible by $T$. This implies that the division of $P_{(I;W)}$ by $T$ results in another polynomial $H:=P_{(I;W)} / T$, with a degree lower than that of $T$.

The prover then evaluates the polynomial $(H\cdot T)/\delta$ in the exponent of the generator $g_1$ at the secret point $\tau$, as explained in \ref{eq:exp_evaluation-poly}. To see how this can be achieved, let $H(x)$ be the quotient polynomial $P/T$:

\begin{equation}
H(x) = H_0\cdot x^0 + H_1\cdot x^1 +\ldots + H_k \cdot x^k
\end{equation}

To evaluate $(H\cdot T)/\delta$ at $\tau$ in the exponent of $g_1$, the prover uses the \concept{Common Reference String} and computes as follows:
\begin{align*}
g_1^{\frac{H(\tau)\cdot T(\tau)}{\delta}} 
 &= \Big(g_1^{\frac{\tau^0\cdot T(\tau)}{\delta}}\Big)^{H_0}\cdot \Big(g_1^{\frac{\tau^1\cdot T(\tau)}{\delta}}\Big)^{H_1}\cdots \Big(g_1^{\frac{\tau^k\cdot T(\tau)}{\delta}}\Big)^{H_k}
\end{align*}

After this has been done, the prover samples two random field elements $r,t\in \F_r$, and uses the \concept{Common Reference String}, the instance variables $I_1$, $\ldots$, $I_n$ and the witness variables $W_1$, $\ldots$, $W_m$ to compute the following curve points:
\begin{align*}
g_1^W & = \Big( g_1^{\frac{\beta\cdot A_{1+n}(\tau)+\alpha\cdot B_{1+n}(\tau)+C_{1+n}(\tau)}{\delta}}\Big)^{W_1}\cdots \Big(g_1^{\frac{\beta\cdot A_{m+n}(\tau)+\alpha\cdot B_{m+n}(\tau)+C_{m+n}(\tau)}{\delta}}\Big)^{W_m}\\
g_1^A & = g_1^\alpha \cdot g_1^{A_0(\tau)} \cdot \Big(g_1^{A_1(\tau)}\Big)^{I_1}\cdots \Big(g_1^{A_n(\tau)}\Big)^{I_n} \cdot \Big(g_1^{A_{n+1}(\tau)}\Big)^{W_1}\cdots \Big(g_1^{A_{n+m}(\tau)}\Big)^{W_m} \cdot \Big(g_1^\delta\Big)^r \\
g_1^B & = g_1^\beta \cdot g_1^{B_0(\tau)} \cdot \Big(g_1^{B_1(\tau)}\Big)^{I_1}\cdots \Big(g_1^{B_n(\tau)}\Big)^{I_n} \cdot \Big(g_1^{B_{n+1}(\tau)}\Big)^{W_1}\cdots \Big(g_1^{B_{n+m}(\tau)}\Big)^{W_m} \cdot \Big(g_1^\delta\Big)^t\\
g_2^B & = g_2^\beta \cdot g_2^{B_0(\tau)} \cdot \Big(g_2^{B_1(\tau)}\Big)^{I_1}\cdots \Big(g_2^{B_n(\tau)}\Big)^{I_n} \cdot \Big(g_2^{B_{n+1}(\tau)}\Big)^{W_1}\cdots \Big(g_2^{B_{n+m}(\tau)}\Big)^{W_m} \cdot \Big(g_2^\delta\Big)^t \\
g_1^C & = g_1^W\cdot g_1^{\frac{H(\tau)\cdot T(\tau)}{\delta}} \cdot \Big(g_1^A\Big)^t \cdot \Big(g_1^B\Big)^r \cdot \Big(g_1^\delta\Big)^{-r\cdot t}
\end{align*}

During this calculation, the group elements $g_1^{A_j(\tau)}$, $g_1^{B_j(\tau)}$, and $g_2^{B_j(\tau)}$ can be obtained from the Common Reference String and the Quadratic Arithmetic Program associated with the problem, as demonstrated in \ref{eq:exp_evaluation-poly}. These points only need to be computed once, and can be made public and reused for multiple proof generations as they are consistent across all instances and witnesses. The remaining group elements are part of the Common Reference String.

After all these computations have been done, a valid zero-knowledge succinct non-interactive argument of knowledge $\pi$ in the Groth\_16 protocol is given by the following three curve points:

\begin{equation}
\label{def:groth16-snark}
\pi = (g_1^A,g_1^C,g_2^B)
\end{equation}

It can be observed that a Groth\_16 zk-SNARK comprises of three curve points, with two being from the $\G_1$ group and one from the $\G_2$ group. This arrangement is purposeful, as $\G_1$ is typically a torsion group of an elliptic curve over a prime field in typical applications, while $\G_2$ is a subgroup of the full torsion group over an extension field, as explained in section \ref{sec:elliptic_curve_pairings}. Since elements from $\G_1$ require less storage space and computations in $\G_1$ are faster than in $\G_2$, this design is optimal.

The witness in a zk-SNARK is encoded in the exponent of a generator of a secure elliptic curve, making it invisible to anyone except the prover. Additionally, the presence of random field elements $r$ and $t$ randomizes each proof, ensuring that no two proofs correspond to the same witness.

\begin{example}[The $3$-factorization Problem]\label{3-fac-snark-compute} To see how a prover might compute 
a zk-SNARK, consider the $3$-factorization problem from \examplename{} \ref{ex:3-factorization}, our protocol parameters from \examplename{} \ref{ex:3-fac-groth-16-params} as well as the \concept{Common Reference String} from \eqref{ex:3-fac-groth-16-crs}.

Our task is to compute a zk-SNARK for the instance $I_1=<11>$ and its constructive proof $<W_1,W_2,W_3,W_4>=<2,3,4,6>$ as computed in \examplename{} \ref{ex:3-fac-R1CS-constr-proof}. As we know from \examplename{} \ref{ex:3-fac-QAP}, the associated polynomial $P_{(I;W)}$ of the Quadratic Arithmetic Program from \examplename{} \ref{ex:3-fac-QAP} is given as follows:
$$
P_{(I;W)} = x^2 + x + 9
$$ 
Since $P_{(I;W)}$ is identical to the target polynomial $T(x)=x^2+x + 9$ in this example, we know from \examplename{} \ref{ex:3-fac-QAP} that the quotient polynomial $H=P/T$ is the constant degree $0$ polynomial:
$$
H(x)= H_0 \cdot x^0 = 1 \cdot x^0
$$
We therefore use $[\frac{\tau^0\cdot T(\tau)}{\delta}]g_1=(26,34)$ from our \concept{Common Reference String} \eqref{ex:3-fac-groth-16-crs} of the $3$-factorization problem and compute as follows:
\begin{align*}
[\frac{H(\tau)\cdot T(\tau)}{\delta}]g_1 &= [H_0](26,34)=[1](26,34)\\
                                   &= (26,34)
\end{align*}

In the next step, we have to compute all group elements required for a proper Groth16 zk-SNARK \eqref{def:groth16-snark}. We start with $g_1^W$. Using scalar products instead of the exponential notation, and $\oplus$ for the group law on the \curvename{BLS6\_6} curve, we have to compute the point $[W]g_1$:
\begin{align*}
[W]g_1 = & \phantom{\oplus} [W_1] g_1^{\frac{\beta\cdot A_{2}(\tau)+\alpha\cdot B_{2}(\tau)+C_{2}(\tau)}{\delta}}
        \oplus [W_2] g_1^{\frac{\beta\cdot A_{3}(\tau)+\alpha\cdot B_{3}(\tau)+C_{3}(\tau)}{\delta}}        
         \oplus [W_3] g_1^{\frac{\beta\cdot A_{4}(\tau)+\alpha\cdot B_{4}(\tau)+C_{4}(\tau)}{\delta}}\\        
         &\oplus [W_4] g_1^{\frac{\beta\cdot A_{5}(\tau)+\alpha\cdot B_{5}(\tau)+C_{5}(\tau)}{\delta}}
\end{align*}

To compute this point, we have to remember that a prover should not be in possession of the simulation trapdoor, hence, they should not know what $\alpha$, $\beta$, $\delta$ and $\tau$ are. In order to compute this group element, the prover therefore needs the \concept{Common Reference String}. Using the logarithmic order from \ref{BLS6-G1-log} and the witness, we get the following:

\begin{align*}
[W]g_1 & = [2](33,34)\oplus [3](26,34)\oplus [4](38,28)\oplus [6](27,9) \\
      & = [2\cdot 2](13,15)\oplus [3\cdot 5](13,15)\oplus [4\cdot 10](13,15)\oplus [6\cdot 7](13,15) \\        
      & = [2\cdot 2+ 3\cdot 5+4\cdot 10+ 6\cdot 7](13,15) = [10](13,15)\\
      & = (38,28)
\end{align*} 

In a next step, we compute $g_1^A$. We sample the random point $r=11$ from $\F_{13}$, using scalar products instead of the exponential notation, and $\oplus$ for the group law on the \texttt{BLS6\_6} curve. We then have to compute the following expression:

\begin{align*}
[A]g_1 = &\phantom{\oplus} [\alpha]g_1 \oplus [A_0(\tau)]g_1 \oplus [I_1][A_1(\tau)]g_1\oplus [W_1][A_2(\tau)]g_1 \oplus [W_2][A_3(\tau)]g_1\\ 
       & \oplus [W_3][A_4(\tau)]g_1\oplus [W_4][A_5(\tau)]g_1\oplus [r][\delta]g_1
\end{align*}

Since we don't know what $\alpha$, $\delta$ and $\tau$ are, we look up $[\alpha]g_1$ and $[\delta]g_1$ from the \concept{Common Reference String}. According to \examplename{} \ref{ex:3-fac-groth-16-crs}, we have $[A_2(\tau)]g_1=(35,15)$, $[A_5(\tau)]g_1=(26,34)$ and $[A_j(\tau)]g_1=\mathcal{O}$ for all other indices $0\leq j\leq 5$. Since $\mathcal{O}$ is the neutral element on $\G_1$, we get the following:
\begin{align*}
[A]g_1 &= (27,34) \oplus \mathcal{O} \oplus [11]\mathcal{O}\oplus [2](35,15) \oplus [3]\mathcal{O} \oplus [4]\mathcal{O}\oplus [6](26,34)\oplus [11](38,15)\\
 &=  (27,34)\oplus [2](35,15)\oplus [6](26,34)\oplus [11](38,15)\\
 &=  [6](13,15)\oplus [2\cdot 9](13,15)\oplus [6\cdot 5](13,15)\oplus [11\cdot 3](13,15)\\ 
 &=  [6+ 2\cdot 9+ 6\cdot 5+ 11\cdot 3](13,15) = [9](13,15)\\
 &= (35,15)
\end{align*}

In order to compute the two curve points $[B]g_1$ and $[B]g_2$, we sample another random element $t=4$ from $\F_{13}$. Using the scalar product instead of the exponential notation, and $\oplus$ for the group law on the \texttt{BLS6\_6} curve, we  have to compute the following expressions:

\begin{align*}
[B]g_1 = &\phantom{\oplus} [\beta]g_1 \oplus [B_0(\tau)]g_1 \oplus [I_1][B_1(\tau)]g_1\oplus [W_1][B_2(\tau)]g_1 \oplus [W_2][B_3(\tau)]g_1\\ 
       & \oplus [W_3][B_4(\tau)]g_1\oplus [W_4][B_5(\tau)]g_1\oplus [t][\delta]g_1\\
[B]g_2 = &\phantom{\oplus} [\beta]g_2 \oplus [B_0(\tau)]g_2 \oplus [I_1][B_1(\tau)]g_2\oplus [W_1][B_2(\tau)]g_2 \oplus [W_2][B_3(\tau)]g_2\\ 
       & \oplus [W_3][B_4(\tau)]g_2\oplus [W_4][B_5(\tau)]g_2\oplus [t][\delta]g_2\\       
\end{align*}

Since we don't know what $\beta$, $\delta$ and $\tau$ are, we look up the associated group elements from the \concept{Common Reference String}. Recall from \ref{ex:3-fac-groth-16-crs} that we can evaluate $[B_j(\tau)]g_1$ without knowing the secret evaluation point $\tau$. Since $B_3=A_2$ and $B_4=A_5$, we have $[B_3(\tau)]g_1=(35,15)$, $[B_4(\tau)]g_1=(26,34)$ according to the computation in \ref{ex:3-fac-groth-16-crs}, and $[B_j(\tau)]g_1=\mathcal{O}$ for all other indices $0\leq j\leq 5$. Since $\mathcal{O}$ is the neutral element on $\G_1$, we get the following:
\begin{align*}
[B]g_1 &= (26,34) \oplus \mathcal{O}\oplus [11]\mathcal{O}\oplus [2]\mathcal{O} \oplus [3](35,15) \oplus [4](26,34)\oplus [6]\mathcal{O}\oplus [4](38,15)\\    
       &= (26,34)\oplus [3](35,15) \oplus [4](26,34)\oplus [4](38,15)\\  
       &= [5](13,15)\oplus [3\cdot 9](13,15) \oplus [4\cdot 5](13,15)\oplus [4\cdot 3](13,15)\\        
       &= [5+3\cdot 9+4\cdot 5+4\cdot 3](13,15) = [12](13,15) \\
       &= (13,28)
\end{align*}

\begin{align*}
[B]g_2 &=(16v^2,28v^3) \oplus \mathcal{O} \oplus [11]\mathcal{O}\oplus [2]\mathcal{O} \oplus [3](37v^2,16v^3)\oplus [4](16v^2,28v^3)\oplus [6]\mathcal{O}\oplus [4](42v^2,16v^3)\\    
         &=(16v^2,28v^3)\oplus [3](37v^2,16v^3)\oplus [4](16v^2,28v^3)\oplus [4](42v^2,16v^3)\\
         &=[5](7v^2,16v^3)\oplus [3\cdot 9](7v^2,16v^3)\oplus [4\cdot 5](7v^2,16v^3)\oplus [4\cdot 3](7v^2,16v^3)\\          
         &=[5+3\cdot 9+4\cdot 5+4\cdot 3](7v^2,16v^3)=[12](7v^2+16v^3)\\
         &= (7v^2,27v^3)     
\end{align*}

In a last step, we combine the previous computations to compute the point $[C]g_1$ in the group $\G_1$ as follows:
\begin{align*}
[C]g_1 & = [W]g_1\oplus [\frac{H(s)\cdot T(\tau)}{\delta}]g_1 \oplus [t][A]g_1 \oplus [r][B]g_1 \oplus [-r\cdot t][\delta]g_1\\
       & = (38,28)\oplus (26,34) \oplus [4](35,15) \oplus [11](13,28) \oplus [-11\cdot 4](38,15)\\       
       & = [10](13,15)\oplus [5](13,15) \oplus [4\cdot 9](13,15) \oplus [11\cdot 12](13,15) \oplus [-11\cdot 4\cdot 3](13,15)\\    
       & = [10+5+4\cdot 9+11\cdot 12-11\cdot 4\cdot 3](13,15)=[12](13,15)\\
       & = (13,28)
\end{align*}
Given the instance $I_1=<11>$, we can now combine these computations and see that the following $3$ curve points are a zk-SNARK for the witness $<W_1,W_2,W_3,W_4>=<2,3,4,6>$:
\begin{equation}
\label{ex:3-fac-groth-16-snark}
\pi=((35,15),(13,28),(7v^2,27v^3))
\end{equation}

We can now publish this zk-SNARK, or send it to a designated verifier. Note that, if we had sampled different values for $r$ and $t$, we would have computed a different zk-SNARK for the same witness. The zk-SNARK, therefore, hides the witness perfectly, which means that it is impossible to reconstruct the witness from the zk-SNARK.
\end{example}
\begin{example}[The 3-Factorization Problem in Circom and Snark.js]
\label{ex:3-fac-groth-16-prover-circom} The performance of the Groth\_16 zk-SNARK prover phase in practical applications can be evaluated by studying our Circom implementation of the $3$-factorization problem \ref{ex:3-fac-circom}, the corresponding parameter set as outlined in example \ref{ex:3-fac-groth-16-params-circom}, and the Common Reference String as described in example \ref{ex:3-fac-groth-16-setup-circom}.

Given an instance $I$, it is established in \ref{r1cs-constructive-proofs} that a constructive proof for the statement "Given instance $I$, there exists a witness $W$ such that $(I;W)$ belongs to the language $\mathcal{L}_R$" requires knowledge of a witness $W$ such that $(I;W)$ is a solution to the R1CS generated from \ref{ex:3-fac-circom}.

Circom defines an instance as the collection of all public signals, and the witness as the set of all assignments to the circuit that are not public signals. Besides instance and witness, Circom introduces the idea of input signals and a witness generator. This generator calculates the values for both instance and witness based on the provided inputs.

To further elaborate, we start by selecting arbitrary input values to our problem. Since the circuit is defined over the scalar field $\F_{bn128}$ of the curve $\curvename{alt\_bn128}$, and there are three input signals $x1$, $x2$, and $x3$ present in the circuit, we can use Sage to randomly generate three elements from $\F_{bn128}$. Utilizing the definition of $\curvename{alt\_bn128}$ as outlined in example \ref{BN128}, we obtain:
\begin{sagecommandline}
sage: r = bn128.order() 
sage: Fbn128 = GF(r) # bn128 scalar field field
sage: x1 = Fbn128.random_element()
sage: x2 = Fbn128.random_element()
sage: x3 = Fbn128.random_element()
\end{sagecommandline} 
To facilitate the use of these input values with Circom's witness generator program, they must be written into a JSON format file.
\begin{lstlisting}
{
"x1": 266454826700390499788624045644422204835838308568801104096964341478260924069,
"x2": 17022543691211744762566166588937408281011290768059146405469762658080007243141,
"x3":2169708499392809782734482748125393322939898426476751716891099115492318742078 
}
\end{lstlisting} 
The file containing the input values can be saved as \fname{input.json}, and the node.js environment can be utilized to run Circom's Javascript/WASM program, \fname{generate\_witness.js}, to generate the witness based on the instance and the R1Cs:
\\
\\
\texttt{:\$ node <PATH\_TO>/generate\_witness.js three\_fac.wasm input.json\\ witness.wtns}
\\
\\
It is important to recognize that in Circom, the witness encompasses both the instance and the witness as defined in our context. In other words, Circom's witness contains both the private and public assignments to the circuit and the solution to the R1Cs. It serves as a constructive proof to the problem.

With the obtained witness, we can now use Snark.js to convert the constructive proof into a zk-SNARK, utilizing the Common Reference String from example \ref{ex:3-fac-groth-16-params-circom}:
\\
\\
\texttt{:\$ snarkjs groth16 prove three\_fac\_final.zkey witness.wtns \\ proof.json public.json}
\\
\\
The execution of this command will result in the creation of two files: \fname{proof.json}, containing the actual proof represented by three curve points, and \fname{public.json}, which holds the values of the instance. 

It's important to understand that in Circom, the instance and input values are distinct entities. The instance contains all public values, including those that are not input values but generated during witness generation. On the other hand, some input values may be designated as private and therefore not included in the instance. 
\end{example}

\begin{exercise} 
\label{ex:baby-jubjub-circom-prover}
Consider exercise \ref{ex:baby-jubjub-circom} and the CRS from exercise \ref{ex:baby-jubjub-circom-setupt}. Use Sage to generate a valid curve point on the Baby-JubJub curve in twisted Edwards form, that is not the neutral element and use this point as input to the circuit. Generate a witness for this input and use Snark.js to compute an instance as well as a zk-SNARK for this witness. 
\end{exercise}

\subsection{The Verification Phase}
\label{sec:groth16-verifier}

TODO: CHECK THAT ALL ELEMENTS OF THE SNARK HAVE THE CORRECT TYPE

The objective of the verification phase in a Groth\_16 zk-SNARK, given a Rank-1 Constraint System $R$, an instance $I = <I_1, \ldots, I_n>$, and a zk-SNARK $\pi$ (as defined in \ref{def:groth16-snark}), is to confirm that $\pi$ constitutes a valid proof. If the simulation trapdoor is no longer present and the proof passes the verification checks, the verifier can be convinced that there exists a witness $W = <W_1, \ldots, W_m>$ such that $(I;W)$ is a word in the language of $R$. 

To achieve this in the Groth\_16 protocol, we assume that any verifier is able to compute the pairing map $e(\cdot,\cdot)$ efficiently, and has access to the \concept{Common Reference String} used to produce the zk-SNARK $\pi$. In order to verify the zk-SNARK with respect to the instance $<I_1,\ldots, I_n>$, the verifier computes the following curve point:
\begin{align*}
g_1^I & = \Big(g_1^{\frac{\beta\cdot A_{0}(\tau)+\alpha\cdot B_{0}(\tau)+C_{0}(\tau)}{\gamma}}\Big)\cdot \Big(g_1^{\frac{\beta\cdot A_{1}(\tau)+\alpha\cdot B_{1}(\tau)+C_{1}(\tau)}{\gamma}}\Big)^{I_1} \cdots \Big(g_1^{\frac{\beta\cdot A_{n}(\tau)+\alpha\cdot B_{n}(\tau)+C_{n}(\tau)}{\gamma}}\Big)^{I_n}\\
\end{align*}
With this group element, the verifier is able to verify the zk-SNARK $\pi=(g_1^A,g_1^C,g_2^B)$ by checking the following equation using the pairing map:
\begin{equation}
\label{def:groth16-verifier-equation}
e(g_1^A, g_2^B) = e(g_1^\alpha,g_2^\beta)\cdot e(g_1^I,g_2^\gamma)\cdot e(g_1^C,g_2^\delta)
\end{equation}

If the equation holds true, the verifier outputs \texttt{accept} and the equation does not hold, the verifier outputs \texttt{reject}.

\begin{remark}
As stated in section \ref{sec:elliptic_curve_pairings}, computing pairings in secure pairing groups is a computationally expensive. In the Groth\_16 protocol, three pairings are necessary for verifying the zk-SNARK, with the pairing $e(g_1^\alpha,g_2^\beta)$ being independent of the proof and thus can be computed once and included as part of the verifier key.

According to \cite{Groth16}, the minimum number of pairings required for any protocol with similar properties is two. The Groth\_16 protocol therefore represents a near-optimal solution in this regard. The same paper describes an adaptation that only uses two pairings, but it requires more computational overhead. The use of three pairings strikes a balance between efficiency and performance, making the Groth\_16 protocol the most efficient of its kind to date.
\end{remark}

\begin{example}[The $3$-factorization Problem]
\label{3-fac-snark-verifier} To see how a verifier might verify  
a zk-SNARK for some given instance $I$, consider the $3$-factorization problem from \examplename{} \ref{ex:3-factorization}, our protocol parameters from \examplename{} \ref{ex:3-fac-groth-16-params}, the \concept{Common Reference String} from \eqref{ex:3-fac-groth-16-crs} as well as the zk-SNARK $\pi=((35,15),(27,9),(7v^2,27v^3))$ from \examplename{}  \eqref{ex:3-fac-groth-16-snark}, which claims to be an argument of knowledge for a witness for the instance $I_1=<11>$.

In order to verify the zk-SNARK for that instance, we first compute the curve point $g_1^I$. Using scalar products instead of the exponential notation, and $\oplus$ for the group law on the \texttt{BLS6\_6} curve, we have to compute the point $[I]g_1$ as follows:

\begin{align*}
[I]g_1 = & [\frac{\beta\cdot A_{0}(\tau)+\alpha\cdot B_{0}(\tau)+C_{0}(\tau)}{\gamma}]g_1 \oplus [I_1][\frac{\beta\cdot A_{1}(\tau)+\alpha\cdot B_{1}(\tau)+C_{1}(\tau)}{\gamma}]g_1
\end{align*}

To compute this point, we have to remember that a verifier should not be in possession of the simulation trapdoor, which means that they should not know what $\alpha$, $\beta$, $\gamma$ and $\tau$ are. In order to compute this group element, the verifier therefore needs the \concept{Common Reference String}. Using the logarithmic order from \eqref{BLS6-G1-log} and instance $I_1$, we get the following:

\begin{align*}
[I]g_1 & = [\frac{\beta\cdot A_{0}(\tau)+\alpha\cdot B_{0}(\tau)+C_{0}(\tau)}{\gamma}]g_1 \oplus [I_1][\frac{\beta\cdot A_{1}(\tau)+\alpha\cdot B_{1}(\tau)+C_{1}(\tau)}{\gamma}]g_1\\
       & = \mathcal{O} \oplus [11](33,9)\\
       & = [11\cdot 11](13,15) = [4](13,15)\\
       & = (35,28)
\end{align*} 

In the next step, we have to compute all the pairings involved in equation \eqref{def:groth16-verifier-equation}. Using the logarithmic order on $\G_1$ \eqref{BLS6-G1-log} and $\G_2$ \eqref{BLS6-G2-log} as well as the bilinearity of the pairing map we get the following:

\begin{align*}
e([A]g_1,[B]g_2) & = e((35,15),(7v^2,27v^3))
                   = e([9](13,15),[12](7v^2,16v^3))\\
               & = e((13,15),(7v^2,16v^3))^{9\cdot 12}\\
               & = e((13,15),(7v^2,16v^3))^{108}\\
e([\alpha]g_1,[\beta]g_2) & = e((27,34),(16v^2,28v^3)) 
                            = e([6](13,15),[5](7v^2,16v^3))\\
               & = e((13,15),(7v^2,16v^3))^{6\cdot 5}\\
               & = e((13,15),(7v^2,16v^3))^{30}\\   
e([I]g_1,[\gamma]g_2) & = e((35,28),(37v^2,27v^3)) 
                            = e([4](13,15),[4](7v^2,16v^3))\\
               & = e((13,15),(7v^2,16v^3))^{4\cdot 4}\\
               & = e((13,15),(7v^2,16v^3))^{16}\\ 
e([C]g_1,[\delta]g_2) & = e((13,28),(42v^2,16v^3)) 
                            = e([12](13,15),[3](7v^2,16v^3))\\
               & = e((13,15),(7v^2,16v^3))^{12\cdot 3}\\
               & = e((13,15),(7v^2,16v^3))^{36}
\end{align*}  

In order to check equation \eqref{def:groth16-verifier-equation}, observe that the target group $\G_T$ of the Weil pairing is a finite cyclic group of order $13$. Exponentiation is therefore done in modular $13$ arithmetic. Accordingly, since $\Zmod{108}{13}=4$, we evaluate the left side of equation \eqref{def:groth16-verifier-equation} as follows:

$$
e([A]g_1,[B]g_2) = e((13,15),(7v^2,16v^3))^{108} =e((13,15),(7v^2,16v^3))^{4}
$$

Similarly, we evaluate the right side of equation \eqref{def:groth16-verifier-equation} using modular $13$ arithmetic and the exponential law $a^x\cdot a^y = a^{x+y}$:

\begin{align*}
e([\alpha]g_1,[\beta]g_2)\cdot e([I]g_1,[\gamma]g_2)\cdot e([C]g_1,[\delta]g_2) =\\
e((13,15),(7v^2,16v^3))^{30}\cdot e((13,15),(7v^2,16v^3))^{16}\cdot e((13,15),(7v^2,16v^3))^{36} =\\
e((13,15),(7v^2,16v^3))^{4}\cdot e((13,15),(7v^2,16v^3))^{3}\cdot e((13,15),(7v^2,16v^3))^{10} =\\
e((13,15),(7v^2,16v^3))^{4+3+10} = \\
e((13,15),(7v^2,16v^3))^{4}
\end{align*}

As we can see, both the left and the right side of equation \eqref{def:groth16-verifier-equation} are identical, which implies that the verification process accepts the zk-SNARK and the verifier outputs \texttt{accept}.
\end{example}

\begin{example}[The 3-Factorization Problem in Circom and Snark.js]
\label{ex:3-fac-groth-16-verifier-circom} The performance of the Groth 16 zk-SNARK verifier phase in practical applications can be evaluated by examining our Circom implementation of the 3-factorization problem \ref{ex:3-fac-circom}, the corresponding parameter set \ref{ex:3-fac-groth-16-params-circom}, the Common Reference String \ref{ex:3-fac-groth-16-setup-circom}, and the generated proof \ref{ex:3-fac-groth-16-prover-circom}.

As we learned from Example \ref{ex:3-fac-groth-16-setup-circom}, a verifier key can be extracted from the Common Reference String. This is beneficial because the verifier key is much smaller in size compared to the full CRS, making it more efficient to store, for example, on a blockchain.

To verify the proof \fname{proof.json} against the instance \fname{public.json}, the verifier utilizes the verification key \fname{verification\_key.json} and employs Snark.js's verification algorithm:
\\
\\
\texttt{:\$ snarkjs groth16 verify verification\_key.json public.json \\ proof.json}
\\
\\
The algorithm either verifies or rejects the Groth\_16 zk-SNARK in relation to the given key and instance. 

The verifier logic in Groth\_16 is simple and consists of a few exponentiations and three pairings, making it suitable for implementation as a smart contract on a blockchain. Circom offers an automation tool for the Solidity language, but a more detailed explanation of this is outside the scope of this book.
\end{example} 

\begin{exercise} 
\label{ex:baby-jubjub-circom-verifier}
Consider exercise \ref{ex:baby-jubjub-circom}, the CRS from exercise \ref{ex:baby-jubjub-circom-setupt} as well as the instance and zk-SNARK from exercise \ref{ex:baby-jubjub-circom-prover} and verify the zk-SNARK against the instance.
\end{exercise}

\subsection{Proof Simulation}
\label{sec:proof_simulation} During the setup phase, a Common Reference String is created along with a simulation trapdoor (as defined in equation \eqref{def:groth16-trapdoor}), which must be discarded at the end of the setup phase. In this section, we will highlight the potential issues with having knowledge of the simulation trapdoor and how it can be used to generate zk-SNARKs without any knowledge of a valid witness.

To clarify, let $I$ be an instance of a R1CS language $L_R$. A zk-SNARK for $L_R$ is considered to be "forged" or "simulated" if it passes verification, but its generation does not require the presence of a witness $W$ such that $(I;W)$ is a word in $L_R$.

To understand how simulated zk-SNARKs can be produced, consider a scenario where an attacker has access to the proper Groth\_16 parameters, a Quadratic Arithmetic Program of the problem, a Common Reference String, and its corresponding simulation trapdoor $\Tau$:

\begin{equation}
\Tau = (\alpha,\beta,\gamma,\delta,\tau)
\end{equation}

Given some instance $I$, the forger's task is to generate a zk-SNARK for this instance that passes the verification process, without having access to any other zk-SNARKs for this instance and without knowledge of a valid witness $W$.

To achieve this in the Groth\_16 protocol, the forger can use the simulation trapdoor in combination with the QAP and two arbitrary field elements $A$ and $B$ from the scalar field $\F_r$ of the pairing groups to compute $g_1^C$ for the instance $<I_1,\ldots,I_n>$ as follows:

\begin{align}
\label{def:groth16-simulated-proof}
g_1^{\frac{A\cdot B}{\delta}}\cdot g_1^{-\frac{\alpha\cdot \beta}{\delta}}\cdot g_1^{-\frac{\beta A_0(\tau) + \alpha B_0(\tau)+ C_0(\tau)}{\delta}}\cdot \Big(g_1^{-\frac{\beta A_1(\tau) + \alpha B_1(\tau)+ C_1(\tau)}{\delta}}\Big)^{I_1}\cdots \Big(g_1^{-\frac{\beta A_n(\tau) + \alpha B_n(\tau)+ C_n(\tau)}{\delta}}\Big)^{I_n}\
\end{align} 

The forger then publishes the zk-SNARK $\pi_{forged} = (g_1^A, g_1^C, g_2^B)$, which will pass the verification process and is computable without the existence of a witness $<W_1,\ldots,W_m>$.

To see that the simulation trapdoor is necessary and sufficient to compute the simulated proof $\pi_{forged}$, first observe that both generators $g_1$ and $g_2$ are known to the forger, as they are part of the \concept{Common Reference String}, encoded as $g_1^{\tau^0}$ and $g_2^{\tau^0}$. The forger is therefore able to compute $g_1^{A\cdot B}$. Moreover, since the forger knows $\alpha$, $\beta$, $\delta$ and $\tau$ from the trapdoor, they are able to compute all factors in the computation of $g_1^C$.

If, on the other hand, the simulation trapdoor is unknown, it is not possible to compute $g_1^C$, since, for example, the computational Diffie-Hellman assumption makes the derivation of $g_1^{\alpha\cdot \beta}$ from $g_1^\alpha$ and $g_1^\beta$ infeasible.

\begin{example}[The $3$-factorization Problem]
\label{3-fac-snark-simulator}
To see how a forger might simulate a zk-SNARK for some given instance $I$, consider the $3$-factorization problem from  \examplename{} \ref{ex:3-factorization}, our protocol parameters from \eqref{ex:3-fac-groth-16-params}, the \concept{Common Reference String} from \examplename{} \ref{ex:3-fac-groth-16-crs} and the simulation trapdoor $\Tau = (6,5,4,3,2)$ of that CRS.

In order to forge a zk-SNARK for instance $I_1=<11>$, we don't need a constructive proof for the associated Rank-1 Constraint System, which implies that we don't have to execute the circuit $C_{3.fac}(\F_{13})$ from \examplename{} \ref{ex:3-fac-zk-circuit}. Instead, we have to choose $2$ arbitrary elements $A$ and $B$ from $\F_{13}$, and compute $g_1^A$, $g_2^B$ and $g_1^C$ as defined in \ref{def:groth16-simulated-proof}. We choose $A=9$ and $B=3$, and, since $\delta^{-1}=3$, we compute as follows:

\begin{align*}
[A]g_1 =& [9](13,15) = (35,15)\\
[B]g_2 =& [3](7v^2,16v^3) = (42v^2,16v^3)\\
[C]g_1 =& [\frac{A\cdot B}{\delta}]g_1\oplus 
           [-\frac{\alpha\cdot\beta}{\delta}]g_1\oplus 
      [-\frac{\beta A_0(\tau) + \alpha B_0(\tau)+ C_0(\tau)}{\delta}]g_1\oplus\\
      &[I_1][-\frac{\beta A_1(\tau) + \alpha B_1(\tau)+ C_1(\tau)}{\delta}]g_1\\      
     = & [(9\cdot 3)\cdot 9 ](13,15)\oplus 
      [-(6\cdot 5)\cdot 9](13,15)\oplus 
      [0](13,15)\oplus 
      [11][-(7\cdot 2 + 4)\cdot 9](13,15)\\      
     = &[9](13,15)\oplus [3](13,15)\oplus [12](13,15)= [11](13,15)\\       
     = &(33,9)
\end{align*}

This is all we need to generate our forged proof for the $3$-factorization problem. We publish the simulated zk-SNARK:
$$
\pi_{fake}=((35,15),(33,9),(42v^2,16v^3))
$$

Despite the fact that this zk-SNARK was generated without knowledge of a proper witness, it is indistinguishable from a zk-SNARK that proves knowledge of a proper witness. 

To see that, we show that our forged SNARK passes the verification process. In order to verify $\pi_{fake}$, we proceed as in \secname{} \ref{sec:groth16-verifier} and compute the curve point $g_1^I$ for the instance $I_1=<11>$. Since the instance is the same as in \examplename{} \eqref{ex:3-fac-groth-16-snark}, we can parallel the computation from that example:

\begin{align*}
[I]g_1 & = [\frac{\beta\cdot A_{0}(\tau)+\alpha\cdot B_{0}(\tau)+C_{0}(\tau)}{\gamma}]g_1 \oplus [I_1][\frac{\beta\cdot A_{1}(\tau)+\alpha\cdot B_{1}(\tau)+C_{1}(\tau)}{\gamma}]g_1\\
       & = (35,28)
\end{align*} 
In a next step we have to compute all the pairings involved in equation \eqref{def:groth16-verifier-equation}. Using the logarithmic order on $\G_1$ \eqref{BLS6-G1-log} and $\G_2$ \eqref{BLS6-G2-log} as well as the bilinearity of the pairing map we get
\begin{align*}
e([A]g_1,[B]g_2) & = e((35,15),(42v^2,16v^3))
                   = e([9](13,15),[3](7v^2,16v^3))\\
               & = e((13,15),(7v^2,16v^3))^{9\cdot 3}\\ 
               & = e((13,15),(7v^2,16v^3))^{27}\\
e([\alpha]g_1,[\beta]g_2) & = e((27,34),(16v^2,28v^3)) 
                            = e([6](13,15),[5](7v^2,16v^3))\\
               & = e((13,15),(7v^2,16v^3))^{6\cdot 5}\\
               & = e((13,15),(7v^2,16v^3))^{30}\\   
e([I]g_1,[\gamma]g_2) & = e((35,28),(37v^2,27v^3)) 
                            = e([4](13,15),[4](7v^2,16v^3))\\
               & = e((13,15),(7v^2,16v^3))^{4\cdot 4}\\
               & = e((13,15),(7v^2,16v^3))^{16}\\ 
e([C]g_1,[\delta]g_2) & = e((33,9),(42v^2,16v^3)) 
                            = e([11](13,15),[3](7v^2,16v^3))\\
               & = e((13,15),(7v^2,16v^3))^{11\cdot 3}\\
               & = e((13,15),(7v^2,16v^3))^{33}\\                                             
\end{align*}  

In order to check equation \eqref{def:groth16-verifier-equation}, observe that the target group $\G_T$ of the Weil pairing is a finite cyclic group of order $13$. Exponentiation is therefore done in modular $13$ arithmetics. Using this, we evaluate the left side of the verifier equation as follows:
$$
e([A]g_1,[B]g_2) = e((13,15),(7v^2,16v^3))^{27} =e((13,15),(7v^2,16v^3))^{1}
$$
since $\Zmod{27}{13}=1$. Similarly, we evaluate the right side of the verification equation using modular $13$ arithmetics and the exponential law $a^x\cdot a^y = a^{x+y}$. We get
\begin{align*}
e([\alpha]g_1,[\beta]g_2)\cdot e([I]g_1,[\gamma]g_2)\cdot e([C]g_1,[\delta]g_2) =\\
e((13,15),(7v^2,16v^3))^{30}\cdot e((13,15),(7v^2,16v^3))^{16}\cdot e((13,15),(7v^2,16v^3))^{33} =\\
e((13,15),(7v^2,16v^3))^{4}\cdot e((13,15),(7v^2,16v^3))^{3}\cdot e((13,15),(7v^2,16v^3))^{7} =\\
e((13,15),(7v^2,16v^3))^{4+3+7} = \\
e((13,15),(7v^2,16v^3))^{1}
\end{align*}

As we can see, both the left and the right side of the verifier equation are identical, which implies that the verification process accepts the simulated proof. $\pi_{fake}$ therefore convinces the verifier that a witness to the $3$-factorization problem exists. However, no such witness was really necessary to generate the proof.
\end{example}

\begin{example}[The 3-Factorization Problem in Circom and Snark.js]
\label{ex:3-fac-groth-16-simulator-circom} As of the time of writing, Snark.js does not have an algorithm to generate simulated proofs using a given simulation trapdoor.
\end{example}

%\subsection{Proof Mutability} As we have seen in the previous paragraph, given some instance $I$, knowledge of the simulation trapdoor allows for the computation of a valid zk-SNARK without knowledge of an actual witness for that instance. 

%Another way to construct 

%To see this, let $\pi=(g_1^A, g_1^C, g_2^B)$ be a zk-Snark for some instance $I$ in the Groth16 protocol. Then for any non zero field element $a\in\F_r$, another proof $\pi'$ is given by
%\begin{equation}
%\pi=\Big(\Big(g_1^A\Big)^a, \Big(g_1^C\Big)^a, \Big(g_2^B\Big)^{a^2}\Big)
%\end{equation}  
%To see this recall from XXX\sme{add reference} that a verifier checks the validity of any given SNARK by computing the equation $e(g_1^A, e_2^B) = e(g_1^\alpha,g_2^\beta)\cdot e(g_1^I,g_2^\gamma)\cdot e(g_1^C,g_2^\delta)$. However, if that equation holds true for the proof $\pi$ it it also satisfied for $\pi'$, since
%\begin{align*}
%e(g_1^A, e_2^B) & = e(g_1^\alpha,g_2^\beta)\cdot e(g_1^I,g_2^\gamma)\cdot e(g_1^C,g_2^\delta) & \Leftrightarrow\\
%\Big(e(g_1^A, e_2^B)\Big^{a^2} &= \Big(e(g_1^\alpha,g_2^\beta)\cdot e(g_1^I,g_2^\gamma)\cdot e(g_1^C,g_2^\delta)\Big^{a^2} & \Leftrightarrow\\  
%e((g_1^A)^a, (e_2^B)^a) &= \Big(e(g_1^\alpha,g_2^\beta)\cdot e(g_1^I,g_2^\gamma)\cdot e(g_1^C,g_2^\delta)\Big^a & \Leftrightarrow\\ 
%\end{align*} 







% ========================= For version 2


\begin{comment}
% Unfortunately too much for the first version of the book. Will finish that
% another time ... With a better pend and paper hash function.
\begin{example}[Player exchangeable multi party ceremony for the factorization snark] In this example, we want to simulate a real world player exchangeable multi party ceremony for our factorization snark XXX\sme{add reference} as explained in XXX\sme{add reference}.

We use our TinyMD5 hash function XXX\sme{add reference} to hash to $\mathbb{G}_2$.


We assume that we have a coordinator $Alice$ together with three parties $Bob$, $Carol$ and $Dave$ that want to contribute their randomness to the protocol. Since the degree $n$ of the target polynomial is $2$, we need to compute the \concept{Common Reference String}
$$
CRS= \left\{\right\}
$$
For contributor $j>0$ in phase $l$ to compute the proof of knowledge XXX\sme{add reference}, we need to define the $transcript_{l,j-1}$ of the previous round. We define it as sha256 of $MPC_{l,j-1}$. To be more precise, we define
$$
transcript_{1,j-1}= 
MD5(
'[s]g_1 [s]g_2 [s^2] g_1 [\alpha]g_1 [\alpha\cdot s]g_1
[\beta]g_1 [\beta]g_2[\beta \cdot s]g_1'
)
$$
The only thing actually important about the transcript, is that it is publicly available data, that is not accesible for anyone before the MPC-data of round $j-1$ in phase $l$ exists.

We start with the first round usually called the 'powers of tau' EXPLAIN THAT TERM...
The computation is initialized With $s=1$, $\alpha=1$, $\beta=1$. Hence the computation starts with the following data
$$
MPC_{1,0}= \left\{
\begin{array}{lcl}
([s]g_1, [s]g_2) &=& ((13,15),(7v^2,16v^3))\\ 
{}[s^2] g_1 &=& (13,15)\\
{}[\alpha]g_1 &=& (13,15)\\ 
{}[\alpha\cdot s]g_1 &=& (13,15)\\ 
([\beta]g_1,[\beta]g_2) &=& ((13,15),(7v^2,16v^3))\\ 
{}[\beta \cdot s]g_1 &=& (13,15)
\end{array}
\right\}
$$
Then 
\begin{multline*}
transcript_{1,0}=\\ 
MD5('(13,15)(7v^2,16v^3)(13,15)(13,15)(13,15)(13,15)(7v^2,16v^3)(13,15)') =\\ f2baea4d3dba5eef5c63bb210920e7d9
\end{multline*}
We obtain that hash by computing

$printf '\%s' "(13,15)(7v\textasciicircum 2,16v\textasciicircum 3)(13,15)(13,15)(13,15)(13,15)(7v\textasciicircum 2,16v\textasciicircum 3)(13,15)" | md5sum$
% note the actual code is printf '%s' "(13,15)(7v^2,16v^3)(13,15)(13,15)(13,15)(13,15)(7v^2,16v^3)(13,15)" | md5sum

Everyone agreed that the MPC starts on the 21.03.2020 and everyone can contribute for exactly a year until the 20.03.2021. 


  
It then proceeds in a round robin style, starting with Bob, who obtains that data in $MPC_{1,0}$ and then computes his contribution. Lets assume that $Bob$ is honest and that bought 
a 13-sided dice (PICTURE OF 13-SIDED DICE) to randomly find three secret field values from our prime field $\F_{13}$. He though the dice and got $\alpha = 4$, $\beta=8$ and $s= 2$. He then updates $MPC_{1,0}$:  
$$
MPC_{1,1}= \left\{
\begin{array}{lclcl}
([s]g_1, [s]g_2) &=& ([2](13,15),[2](7v^2,16v^3)) &=& ((33,34),(10v^2,28v^3))\\ 
{}[s^2] g_1 &=& [4](13,15)&=& (35,28)\\
{}[\alpha]g_1 &=& [4](13,15)&=& (35,28)\\ 
{}[\alpha\cdot s]g_1 &=& [8](13,15) &=& (26,9)\\ 
([\beta]g_1,[\beta]g_2) &=& ([8](13,15),[8](7v^2,16v^3))&=& ((26,9),(16v^2,15v^3))\\ 
{}[\beta \cdot s]g_1 &=& [3](13,15)&=& (38,15)
\end{array}
\right\}
$$
In addition, we compute as follows:
$$
POK_{1,1} \left\{
\begin{array}{lcl}
y_{s} &=& POK(2, f2baea4d3dba5eef5c63bb210920e7d9) = ((33,34),(16v^2 , 28v^3))\\
y_{\alpha} &=& POK(4, f2baea4d3dba5eef5c63bb210920e7d9) = ((35,28),(10v^2 , 15v^3))\\ 
y_{\beta} &=& POK(8, f2baea4d3dba5eef5c63bb210920e7d9) = ((26,9),(16v^2 , 28v^3))\\
\end{array}
\right\}
$$
since $[s]g_1 = (33,34)$, $[\alpha] g_1 = (35,28)$ and $[\beta] g_1 = (26,9)$. as well as 
\begin{align*}
TinyMD5_{2}('(33,34)f2baea4d3dba5eef5c63bb210920e7d9') =\\ H_2(MD5('(33,34)f2baea4d3dba5eef5c63bb210920e7d9').trunc(3))=\\ H_2(2066b3b6b6d97c46c3ac6ee2ccd23ad9.trunc(3))= H_2(ad9) = \\
H_2(101 011 011 001)=\\
[8\cdot 4^{1}\cdot 5^{0}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{0}\cdot 3^{1}\cdot 8^{1}](42v^2 , 16v^3 )+\\
[2\cdot 3^{0}\cdot 9^{1}\cdot 11^{1}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{0}\cdot 10^{1}](10v^2 , 15v^3 ) =\\
[8\cdot 4\cdot 7](7v^2 , 16v^3)+
[12\cdot 3\cdot 8](42v^2 , 16v^3 )+
[2\cdot 9\cdot 11](17v^2 , 15v^3 ) +
[3\cdot 10](10v^2 , 15v^3 ) =\\
[8\cdot 4\cdot 7](7v^2 , 16v^3)+
[12\cdot 3\cdot 8](42v^2 , 16v^3 )+
[2\cdot 9\cdot 11](17v^2 , 15v^3 ) +
[3\cdot 10](10v^2 , 15v^3 ) =\\
[3](7v^2 , 16v^3)+
[2](42v^2 , 16v^3 )+
[3](17v^2 , 15v^3 ) +
[4](10v^2 , 15v^3 )=\\
[3](7v^2 , 16v^3)+
[2*3](7v^2 , 16v^3 )+
[3*7](7v^2 , 16v^3 ) +
[4*11](7v^2 , 16v^3 )=\\
(42v^2 , 16v^3)+
(17v^2 , 28v^3 )+
(16v^2 , 15v^3 ) +
(16v^2 , 28v^3 )=\\
[3](7v^2 , 16v^3)+
[6](7v^2 , 16v^3 )+
[8](7v^2 , 16v^3 ) +
[5](7v^2 , 16v^3 )=\\
[3+6+8+5](7v^2 , 16v^3)=
(37v^2 , 16v^3 )
\end{align*}
So we get $[2](37v^2 , 16v^3 )= (16v^2 , 28v^3 )$

===================

\begin{align*}
TinyMD5_{2}('(35,28)f2baea4d3dba5eef5c63bb210920e7d9') =\\ H_2(MD5('(35,28)f2baea4d3dba5eef5c63bb210920e7d9').trunc(3))=\\ H_2(ad54fa3674f6a84fab9208d7a94c9163.trunc(3))= H_2(163) = \\
H_2(000 101 100 011)=\\
[8\cdot 4^{0}\cdot 5^{0}\cdot 7^{0}](7v^2 , 16v^3)+
[12\cdot 1^{1}\cdot 3^{0}\cdot 8^{1}](42v^2 , 16v^3 )+\\
[2\cdot 3^{1}\cdot 9^{0}\cdot 11^{0}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{1}\cdot 10^{1}](10v^2 , 15v^3 ) = \\
[8](7v^2 , 16v^3)+
[12\cdot 8](42v^2 , 16v^3 )+
[2\cdot 3](17v^2 , 15v^3 ) +
[3\cdot 9\cdot 10](10v^2 , 15v^3 ) = \\
[8](7v^2 , 16v^3)+
[5](42v^2 , 16v^3 )+
[6](17v^2 , 15v^3 ) +
[10](10v^2 , 15v^3 ) = \\
[8](7v^2 , 16v^3)+
[5*3](7v^2 , 16v^3 )+
[6*7](7v^2 , 16v^3 ) +
[10*11](7v^2 , 16v^3 )=\\
(16v^2 , 15v^3)+
(10v^2 , 28v^3 )+
(42v^2 , 16v^3 ) +
(17v^2 , 28v^3 )=\\
[8](7v^2 , 16v^3)+
[2](7v^2 , 16v^3 )+
[3](7v^2 , 16v^3 ) +
[6](7v^2 , 16v^3 )=\\
[8+2+3+6](7v^2 , 16v^3)=
(17v^2 , 28v^3 )
\end{align*}
So we get $[4](17v^2 , 28v^3 )= (10v^2 , 15v^3 )$

\begin{align*}
TinyMD5_{2}('(26,9)f2baea4d3dba5eef5c63bb210920e7d9') =\\ H_2(MD5('(26,9)f2baea4d3dba5eef5c63bb210920e7d9').trunc(3))=\\ H_2(b87b632f7027ad78cadc2452beb30e9a.trunc(3))= H_2(e9a) = \\
H_2(111 010 011 010)=\\
[8\cdot 4^{1}\cdot 5^{1}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{0}\cdot 3^{1}\cdot 8^{0}](42v^2 , 16v^3 )+\\
[2\cdot 3^{0}\cdot 9^{1}\cdot 11^{1}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{1}\cdot 10^{0}](10v^2 , 15v^3 )= \\
[8\cdot 4\cdot 5\cdot 7](7v^2 , 16v^3)+
[12\cdot 3](42v^2 , 16v^3 )+
[2\cdot 9\cdot 11](17v^2 , 15v^3 ) +
[3\cdot 9](10v^2 , 15v^3 )= \\
[2](7v^2 , 16v^3)+
[10](42v^2 , 16v^3 )+
[3](17v^2 , 15v^3 ) +
[1](10v^2 , 15v^3 )= \\
[2](7v^2 , 16v^3)+
[10*3](7v^2 , 16v^3 )+
[3*7](7v^2 , 16v^3 ) +
[1*11](7v^2 , 16v^3 )=\\
(10v^2 , 28v^3)+
(37v^2 , 27v^3 )+
(16v^2 , 15v^3 ) +
(10v^2 , 15v^3 )=\\
[2](7v^2 , 16v^3)+
[4](7v^2 , 16v^3 )+
[8](7v^2 , 16v^3 ) +
[11](7v^2 , 16v^3 )=\\
[2+4+8+11](7v^2 , 16v^3)=
(7v^2 , 27v^3 )
\end{align*}
So we get $[8](17v^2 , 28v^3 )= (16v^2 , 28v^3 )$

So Bob publishes $MPC_{1,1}$ as well as $POK_{1,1}$ and after that its Carols turn. Lets also assume that Carrol is honest. So Carol looks at Bobs data and compute the transcript according to our rules
\begin{multline*}
transcript_{1,1}=\\ 
MD5('
(33,34)(10v^2,28v^3)(35,28)(35,28)(26,9)(26,9)(16v^2,15v^3)(38,15)') =\\ fe72e18b90014062682a77136944e362
\end{multline*}
We obtain that hash by computing

$printf '\%s' "(33,34)(10v^2,28v^3)(35,28)(35,28)(26,9)(26,9)(16v^2,15v^3)(38,15)" | md5sum$

Carol then computes here contribution. Since she is honest she chooses randomly three secret field values from our prime field $\F_{13}$, by invoking her computer. She found $\alpha = 3$, $\beta=4$ and $s= 9$ and updates $MPC_{1,1}$:  
$$
MPC_{1,2}= \left\{
\begin{array}{lclcl}
([s]g_1, [s]g_2) &=& ([9](33,34),[9](10v^2,28v^3)) &=&  ((26,34),(16v^2,28v^3))\\ 
{}[s^2] g_1 &=& [9\cdot 9](35,28) &=& (13,28)\\
{}[\alpha]g_1 &=& [3](35,28) &=& (13,28) \\ 
{}[\alpha\cdot s]g_1 &=& [3\cdot 9](26,9) &=& (26,9)\\ 
([\beta]g_1,[\beta]g_2) &=& ([4](26,9),[4](16v^2,15v^3)) &=& ((27,34),(17v^2,28v^3))\\ 
{}[\beta \cdot s]g_1 &=& [4\cdot 9](38,15) &=& (35,28)
\end{array}
\right\}
$$
In addition, we compute as follows:
$$
POK_{1,2} \left\{
\begin{array}{lcl}
y_{s} &=& POK(9, fe72e18b90014062682a77136944e362) = ((35,15),(17v^2 , 28v^3))\\
y_{\alpha} &=& POK(3, fe72e18b90014062682a77136944e362) = ((38,15),(17v^2 , 15v^3 ))\\ 
y_{\beta} &=& POK(4, fe72e18b90014062682a77136944e362) = ((35,28),(42v^2 , 27v^3 ))\\
\end{array}
\right\}
$$

\begin{align*}
TinyMD5_{2}('(35,15)fe72e18b90014062682a77136944e362') =\\ H_2(MD5('(35,15)fe72e18b90014062682a77136944e362').trunc(3))=\\ H_2(115f145ceffdda73e916dc5ba8ae7354.trunc(3))= H_2(354) = \\
H_2(001 101 010 100)=\\
[8\cdot 4^{0}\cdot 5^{0}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{1}\cdot 3^{0}\cdot 8^{1}](42v^2 , 16v^3 )+\\
[2\cdot 3^{0}\cdot 9^{1}\cdot 11^{0}](17v^2 , 15v^3 ) +
[3\cdot 6^{1}\cdot 9^{0}\cdot 10^{0}](10v^2 , 15v^3 )= \\
[8\cdot 7](7v^2 , 16v^3)+
[12\cdot 8](42v^2 , 16v^3 )+
[2\cdot 9](17v^2 , 15v^3 ) +
[3\cdot 6](10v^2 , 15v^3 )= \\
[4](7v^2 , 16v^3)+
[5](42v^2 , 16v^3 )+
[5](17v^2 , 15v^3 ) +
[5](10v^2 , 15v^3 )= \\
[4](7v^2 , 16v^3)+
[5*3](7v^2 , 16v^3 )+
[5*7](7v^2 , 16v^3 ) +
[5*11](7v^2 , 16v^3 )=\\
(37v^2 , 27v^3)+
(10v^2 , 28v^3 )+
(37v^2 , 16v^3 ) +
(42v^2 , 16v^3 )=\\
[4](7v^2 , 16v^3)+
[2](7v^2 , 16v^3 )+
[9](7v^2 , 16v^3 ) +
[3](7v^2 , 16v^3 )=\\
[4+2+9+3](7v^2 , 16v^3)=
(16v^2 , 28v^3 )
\end{align*}
So we get $[9](16v^2 , 28v^3 )= (17v^2 , 28v^3 )$

\begin{align*}
TinyMD5_{2}('(38,15)fe72e18b90014062682a77136944e362') =\\ H_2(MD5('(38,15)fe72e18b90014062682a77136944e362').trunc(3))=\\ H_2(cc4da0c02c4c1b15e72d6cc6430206ab.trunc(3))= H_2(6ab) = \\
H_2(011 010 101 011)=\\
[8\cdot 4^{0}\cdot 5^{1}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{0}\cdot 3^{1}\cdot 8^{0}](42v^2 , 16v^3 )+\\
[2\cdot 3^{1}\cdot 9^{0}\cdot 11^{1}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{1}\cdot 10^{1}](10v^2 , 15v^3 )= \\
[8\cdot 5\cdot 7](7v^2 , 16v^3)+
[12\cdot 3](42v^2 , 16v^3 )+
[2\cdot 3\cdot 11](17v^2 , 15v^3 ) +
[3\cdot 9\cdot 10](10v^2 , 15v^3 )= \\
[7](7v^2 , 16v^3)+
[10](42v^2 , 16v^3 )+
[1](17v^2 , 15v^3 ) +
[10](10v^2 , 15v^3 )= \\
[7](7v^2 , 16v^3)+
[10*3](7v^2 , 16v^3 )+
[1*7](7v^2 , 16v^3 ) +
[10*11](7v^2 , 16v^3 )=\\
(17v^2 , 15v^3)+
(17v^2 , 28v^3 )+
(17v^2 , 15v^3 ) +
(17v^2 , 28v^3 )=\\
[7](7v^2 , 16v^3)+
[4](7v^2 , 16v^3 )+
[7](7v^2 , 16v^3 ) +
[6](7v^2 , 16v^3 )=\\
[7+4+7+6](7v^2 , 16v^3)=
(10v^2 , 15v^3)
\end{align*}
So we get $[3](10v^2 , 15v^3 )= (17v^2 , 15v^3 )$

\begin{align*}
TinyMD5_{2}('(35,28)fe72e18b90014062682a77136944e362') =\\ H_2(MD5('(35,28)fe72e18b90014062682a77136944e362').trunc(3))=\\ H_2(502323bc55c75f7189fad7999c9f1708.trunc(3))= H_2(708) = \\
H_2(011 100 001 000)=\\
[8\cdot 4^{0}\cdot 5^{1}\cdot 7^{1}](7v^2 , 16v^3)+
[12\cdot 1^{1}\cdot 3^{0}\cdot 8^{0}](42v^2 , 16v^3 )+\\
[2\cdot 3^{0}\cdot 9^{0}\cdot 11^{1}](17v^2 , 15v^3 ) +
[3\cdot 6^{0}\cdot 9^{0}\cdot 10^{0}](10v^2 , 15v^3 )= \\
[8\cdot 5\cdot 7](7v^2 , 16v^3)+
[12](42v^2 , 16v^3 )+
[2\cdot 11](17v^2 , 15v^3 ) +
[3](10v^2 , 15v^3 )= \\
[7](7v^2 , 16v^3)+
[12](42v^2 , 16v^3 )+
[9](17v^2 , 15v^3 ) +
[3](10v^2 , 15v^3 )= \\
[7](7v^2 , 16v^3)+
[12*3](7v^2 , 16v^3 )+
[9*7](7v^2 , 16v^3 ) +
[3*11](7v^2 , 16v^3 )=\\
(17v^2 , 15v^3)+
(42v^2 , 27v^3 )+
(10v^2 , 15v^3 ) +
(17v^2 , 15v^3 )=\\
[7](7v^2 , 16v^3)+
[10](7v^2 , 16v^3 )+
[11](7v^2 , 16v^3 ) +
[7](7v^2 , 16v^3 )=\\
[7+10+11+7](7v^2 , 16v^3)=
(37v^2 , 16v^3)
\end{align*}
So we get $[4](37v^2 , 16v^3 )= (42v^2 , 27v^3 )$

Dave thinks he can outsmart the system, Since he is the last to contribute, he just makes up an entirely new $MPC$ that does not contain any randomness from the previous contributors. He thinks he can do that because, no one can distinguish his $MPC_{1,3}$ from a correct one. If this is done in a smart way, he will even be able to compute the correct $POK$s. 

So Dave choses $s=12$, $\alpha=11$ and $\beta=10$ and he will keep those values, hoping to be able to use them later to forge false proofs in the factorization snark. He then compute  
$$
MPC_{1,3}= \left\{
\begin{array}{lcl}
([s]g_1, [s]g_2) &=& ((13,28),(7v^2,27v^3))\\ 
{}[s^2] g_1 &=& (13,15)\\
{}[\alpha]g_1 &=& (33,9)\\ 
{}[\alpha\cdot s]g_1 &=& (33,34)\\ 
([\beta]g_1,[\beta]g_2) &=& ((38,28),(42v^2,27v^3))\\ 
{}[\beta \cdot s]g_1 &=& (38,15)
\end{array}
\right\}
$$
Dave does not delete $s$, $\alpha$ and $\beta$, because if this is accepted as phase one of the \concept{Common Reference String} computation, Dave controls already $3/4$-th of the cheating key to forge proofs. So Dave is careful to get the proofs of knowledge right. He computes the transcript of Carols contribution as 

\begin{multline*}
transcript_{1,2}=\\ 
MD5('
(26,34)(16v^2,28v^3)(13,28)(13,28)(26,9)(27,34)(17v^2,28v^3)(35,28)') =\\ c8e6308fffd47009f5f65e773ae4b499
\end{multline*}

We obtain that hash by computing

$printf '\%s' "(26,34)(16v^2,28v^3)(13,28)(13,28)(26,9)(27,34)(17v^2,28v^3)(35,28)" | md5sum$

\end{example}
\end{comment}
\section{The PLONK Protocol}
\label{sec:PLONK}
The \term{Plonk} protocol, developed by Ariel Gabizon, Zachary Williamson, and Oana Ciobotaru in \cite{gabizon-19}, provides a method for transforming constructive proofs for formal languages into zero-knowledge succinct non-interactive arguments of knowledge. Given groups $\G_1$, $\G_2$, and $\G_3$ of sufficient size, and an efficiently computable pairing map $e(\cdot,\cdot): \G_1 \times \G_2 \to \G_3$ (see \ref{pairing-map}), the resulting zk-SNARK is of constant size, consisting of $9$ elements from $\G_1$ and $6$ elements from the scalar field of $\G_1$, regardless of the instance and witness size. Verification is non-interactive and requires the computation of a number of polynomial evaluations, Fiat-Shamir point generations, exponentiations in $\G_1$, along with two group pairings, in order to verify a single proof.

The zk-SNARK generated by the Plonk protocol is zero-knowledge, has completeness and soundness in the generic bilinear group model, assuming the existence of a trusted third party who executes a preprocessing phase to produce a Common Reference String and a simulation trapdoor. Unlike Groth\_16's protocol, the Common Reference String in the Plonk protocol is universal, meaning it can be used for any circuit up to a certain upper bound on the number of constraints in the circuit. It is essential to trust this party to delete the simulation trapdoor, as anyone possessing it would be able to simulate proofs. As demonstrated in \cite{bowe-17}, it is possible to transform the single-party trusted setup into a multi-party computation that is secure as long as at least one contributor deletes their contribution to the simulation trapdoor. 

To be more precise, let $k\in \N$ be a natural number that defines an upper bound on the maximal number of constraints that the system can handle. Then \term{Plonk parameters} for $k$ are given by the following set:
\begin{equation}
\label{plonk-parameters}
\mathtt{Plonk-Param}(k)=(r, \G_1, \G_2, e(\cdot,\cdot), g_1,g_2, H, k_1,k_2, \mathtt{transcript},\mathtt{PRF}_s)
\end{equation}

In this definition, $\G_1$ and $\G_2$ are finite cyclic groups of order $r$ for some $r> k$, $g_1$ is a generator of $\G_1$, $g_2$ is a generator of $\G_2$ and $e: \G_1 \times \G_2 \to \G_T$ is an efficiently computable, non-degenerate, bilinear pairing for some target group $\G_T$. Moreover $H:=\{1,\omega,\omega^2,\ldots, \omega^{k-1}\}$ is a $k$-th power roots of unity group (See \ref{nth-root-unity}), where $\omega$ is a primitive $k$-th root of unity in $\F_r$ and $k_1, k_2\in \F_r$ are field elements, such that the cosets $k_1\cdot H$ and $k_2\cdot H$ are disjoint and disjoint to $H$. In addition 
\begin{equation}
\mathtt{transcript}: \{0,1\}^* \times \F_r \times \G_1 \to \{0,1\}^* 
\end{equation}
is a transcript function XXX for the message set $\F_r \times \G_1$ and 
\begin{equation}
\mathtt{PRF}_s : \{0,1\}^* \to \F_r
\end{equation} is a family of pseudo random functions parameterized by a seed $s\in \{0,1\}^*$.


Given some Plonk parameters, a \term{Plonk protocol} is then a quadruple of probabilistic polynomial algorithms $(\textsc{Setup},\textsc{Prove},\textsc{Vfy},\textsc{Sim})$ such that the following conditions hold:

\begin{itemize}
\item (Setup-Phase): $(CRS,\Tau)\leftarrow \textsc{Setup}(k)$: Algorithm $\textsc{Setup}$ takes an upper bound on the number of constraints as input and computes a \term{\concept{Common Reference String}} $CRS$ and a \term{simulation trapdoor} $\Tau$.
\item (Prover-Phase): $\pi\leftarrow \textsc{Prove}(R,CRS,I,W)$: Given a constructive proof $(I;W)$ for a Plonk constraint system $R$, algorithm $\textsc{Prove}$ takes the constraint system $R$, the \concept{Common Reference String} $CRS$ and the constructive proof $(I,W)$ as input and computes an zk-SNARK $\pi$.
\item (Verifier Phase): $\{\mathtt{accept},\mathtt{reject}\}\leftarrow \textsc{Vfy}(R,CRS,I,\pi)$:   Algorithm \textsc{Vfy} takes the constraint system $R$, the \concept{Common Reference String} $CRS$, the instance $I$ and the zk-SNARK $\pi$ as input and returns \texttt{reject} or \texttt{accept}.
\item (Proof Simulation): $\pi\leftarrow \textsc{Sim}(R,\tau,CRS, I)$: Algorithm \textsc{Sim} takes the constraint system $R$, the \concept{Common Reference String} $CRS$, the simulation trapdoor $\Tau$ and the instance $I$ as input and returns a zk-SNARK $\pi$. 
\end{itemize}
We will explain these algorithms together with detailed examples in the remainder of this section.

Assuming a trusted third party or the presence of a corresponding multi-party computation for the setup, the protocol is capable of deriving a zk-SNARK from a constructive proof for $R$, provided that the group order $r$ is suitably large, and it contains a $k$-th power roots of unity group, such that $k$ is larger than the number of constraints in the associated Plonk constraint system.

\begin{example}[The 3-Factorization Problem]
\label{ex:3-fac-plonk-params} Consider the $3$-factorization problem from \ref{ex:3-factorization} and its associated Plonk Constraint System from XXX. In this example, we want to agree on a parameter set $(r, \G_1, \G_2, e(\cdot,\cdot), g_1, g_2)$ in order to use the Plonk protocol for our $3$-factorization problem. 

To find proper parameters, first observe that the circuit \ref{ex:3-fac-zk-circuit}, as well as its associated PlCS $R_{3.fac\_zk}$ XXX, are defined over the field $\F_{13}$. We therefore have to choose pairing groups $\G_1$ and $\G_2$ of order $13$. 

We know from \ref{BLS6} that the moon-math curve \texttt{BLS6\_6} has two subgroups $\G_1[13]$ and $\G_2[13]$, which are both of order $13$. The associated Weil pairing $e(\cdot,\cdot)$ \ref{BLS6-weil-pairing} is efficiently computable, bilinear as well as non-degenerate. We therefore choose those groups and the Weil pairing together with the generators $g_1 = (13,15) $ and $g_2=(7v^2,16v^3)$ of $\G_1[13]$ and $\G_2[13]$. 

In order to utilize these groups in Plonk's proof system, we need to decide on an $n$-th power roots of unity group (See XXX) in the scalar field $\F_{13}$ of $\G_1$, that contains no less elements then the number of public input and gate constraints of the circuit combined. Moreover, since we additionally need to consider two distinct cosets of this group in $\F_{13}^*$, we ultimately have to chose some $n$, such that $3\cdot n \leq \F_{13}^*$. 

As we know from XXX our Plonk constraint system for the 3-factorization problem with $1$ public input has $2$ gate constraints and hence the total number of constraints is $3$. This implies that we could either choose $4$-th power roots of unity, or third power roots of unity, since $2$, $3$ $4$, and $6$ are the only factors of $12$ the order of $\F_{13}^*$ and $3\cdot 6 > 12$. 

We decide on $n=4$ and parallel example XXX to compute the group $\sqrt[4]{1}$ in $\F_{13}^*$, as well as a generator $\omega$ of that group. Since $gcd(4,12)=4$, this group is non-trivial and has precisely $4$ elements, as expected. 

As $\F_{13}^*$ comprises only $12$ elements, we can compute all $4$-th power roots by raising each element of $\F_{13}^*$ to the power of $4$. Thus, we obtain:
$$
\begin{array}{lcr}
1^4= 1, &
2^4=3, &
3^4=3, \\
4^4=9, &
5^4=1, &
6^4=9,\\
7^4=9, &
8^4=1, &
9^4=9,\\
10^4=3, &
11^4=3, &
12^4=1
\end{array}
$$
As expected the computations shows that there are $4$ different $4$-th power roots of unity in $\F_{13}$ and using notation \ref{ded:higher_root}, we have
$$
\sqrt[4]{1}= \{1,5,8,12\}
$$
To obtain a primitive $4$-th power root of unity $\omega$, we must identify an element in $\sqrt[4]{1}$ that has an order of $4$. However, as $4$ is not a prime number and has a factor of $2$, not all elements of $\sqrt[4]{1}$ will satisfy this condition.

To demonstrate, consider the element $12$. Since $12^2=12\cdot 12 = 1$, the element $12$ is not a primitive root of unity in $\F_{13}$ ($12$ has order $2$ not order $4$ as expected). Nevertheless, we can find a primitive root of unity by observing that $5^2=12$, and $5^3=8$. Therefore, we conclude that $\omega = 5$ is a primitive $4$-th power root of unity in $\F_{13}$, and we can express the set $H$ of all $4$-th power roots of unity as follows:
$$
H = \{\omega, \omega^2 \ldots, \omega^{n-1}, 1\} = \{5,5^2,5^3,1\} = \{5,12,8,1\}
$$

TODO: COSETS

In addition we have to find two field elements $k_1$ and $k-2$ in $\F_{13}^*$, such that the sets $k_1\cdot H$ and $_k2\cdot H$ are disjoint (contain different element) and are disjoint from $H$ itself. To achieve this, we can choose $k_1$ to be any element not contained in $H$, so we choose $k_1=2$. In addition we can choose $k_2$ to be any element not contained in $H$ and not contained in $k_1\cdot H$, so we choose $k_2=4$ and hence we get
$$
k_1\cdot H = \{10, 11, 3, 2\} \text{ and } k_2\cdot H = \{7, 9, 6, 4\} 
$$ 

This gives the Plonk parameter set:
$$
\mathtt{Groth\_16-Param}(R_{3.fac\_zk})=(13, \G_1[13], \G_2[13], e(\cdot,\cdot), (13,15),(7v^2,16v^3), \{1,5, 12, 8\}, 2, 4)
$$
It should be noted that our choice is not unique. Every pair of finite cyclic groups of order $13$ that has an efficiently computable, non-degenerate, bilinear pairing and every suitable choice of $H$ qualifies as a Plonk parameter set. The situation is similar to real-world applications, where SNARKs with equivalent behavior are defined over different curves, used in different applications.

In the next step, the protocol requires a Lagrange Base XXX on the set $H$, that is we need to compute a set of Lagrange base polynomials of degree $m-1$, where $m$ is the number of elements in $H$. Using equation XXX and the enumeration 
$$
H= \{\omega_1, \omega_2, \omega_3, \omega_4\} = \{\omega^1,\omega^2,\omega^3, \omega^4\} =  \{5,12,8,1\}
$$
 we get the following
\begin{equation}
\begin{array}{rl}
L_1(x) = &  \frac{(x-\omega^2)(x-\omega^3)(x-\omega^4)}{(\omega^1-\omega^2)(\omega^1-\omega^3)(\omega^1-\omega^4)}\\
       = &  \frac{(x-12)(x-8)(x-1)}{(5-12)(5-8)(5-1)}
       = \frac{(x+1)(x+5)(x+12)}{6\cdot 10\cdot 4}
       = \frac{(x^2+6x+5)(x+12)}{6} \\
       = & (x^3 +5x^2 +12x + 8)\cdot 11 \\
       = & 11x^3 +3x^2 +2x + 10\\
L_2(x) = &  \frac{(x-\omega^1)(x-\omega^3)(x-\omega^4)}{(\omega^2-\omega^1)(\omega^2-\omega^3)(\omega^2-\omega^4)}\\
       = &  \frac{(x-5)(x-8)(x-1)}{(12-5)(12-8)(12-1)}
       =    \frac{(x+8)(x+5)(x+12)}{7\cdot 4\cdot 11}
       =    \frac{(x^2+1)(x+1)}{9} \\
       = &   (x^3 +12x^2+x + 12)\cdot 3 \\
       = &  3x^3 +10x^2+ 3x + 10\\
L_3(x) = &  \frac{(x-\omega^1)(x-\omega^2)(x-\omega^4)}{(\omega^3-\omega^1)(\omega^3-\omega^2)(\omega^3-\omega^4)}\\
       = &  \frac{(x-5)(x-12)(x-1)}{(8-5)(8-12)(8-1)}
       =   \frac{(x+8)(x+1)(x+12)}{3\cdot 9\cdot 7}
       =   \frac{(x^2+9x+8)(x+12)}{7} \\
       = &   (x^3 + 8x^2 +12x +5) \cdot 2\\
       = &  2x^3 + 3x^2 +11x +10 \\
L_4(x) = &  \frac{(x-\omega^1)(x-\omega^2)(x-\omega^3)}{(\omega^4-\omega^1)(\omega^4-\omega^2)(\omega^4-\omega^3)}\\
       = &  \frac{(x-5)(x-12)(x-8)}{(1-5)(1-12)(1-8)}
       = \frac{(x+8)(x+1)(x+5)}{9\cdot 2\cdot 6}
       = \frac{(x^2 +9x + 8)(x+5)}{4} \\
       = & (x^3 + x^2 +x + 1)\cdot 10 \\
       = & 10x^3 + 10 x^2 +10x + 10
\end{array}
\end{equation}
Hence we have the Lagrange base
\begin{multline}
\label{ex:lagrange-base-H}
L_H = \{ 11x^3 +3x^2 +2x + 10, 3x^3 +10x^2+ 3x + 10, \\ 2x^3 + 3x^2 +11x +10, 10x^3 + 10 x^2 +10x + 10\}
\end{multline}
In addition to the Lagrange base we also need the vanishing Polynomial $Z_H$ (TODO: Define vanishing polynomial on a set) of the set $H$. According to XXX, we compute $Z_H$ as follows:
\begin{align*}
Z_H(x) = & (x-5)\cdot(x-12)\cdot(x-8)\cdot(x-1) = (x+8)\cdot(x+1)\cdot(x+5)\cdot(x+12) \\
       = & (x^2 + 9x +8) \cdot (x^2 + 4x +8)
       = & x^4 +12
\end{align*}

\begin{sagecommandline}
sage: F13 = GF(13)
sage: F13x = F13['x'] # Polynomial Ring over F13
sage: # point-value representation
sage: S1 = [(5,1),(12,0),(8,0),(1,0)] # L1
sage: S2 = [(5,0),(12,1),(8,0),(1,0)] # L2
sage: S3 = [(5,0),(12,0),(8,1),(1,0)] # L3
sage: S4 = [(5,0),(12,0),(8,0),(1,1)] # L4
sage: # coefficient representation
sage: F13x.lagrange_polynomial(S1)
sage: F13x.lagrange_polynomial(S2)
sage: F13x.lagrange_polynomial(S3)
sage: F13x.lagrange_polynomial(S4)
\end{sagecommandline}
\end{example}


\subsection{Universal Setup Phase}
TODO: Choose $H$ in this phase and compute $L_H$ as well as $g_1^{L_H}$ in this phase.


Generating zk-SNARKs from constructive proofs in the Plonk protocol requires two preprocessing phases. The first phase, which is universal, depends only on an upper bound $m$ on the number of gate and public input constraints in a Plonk Constraint System. Its output is a \textit{Universal Common Reference String} (UCRS) that is applicable to all Plonk Constraint Systems of size $\leq m$. This reference string is necessary to generate a circuit-specific Common Reference String in the second phase. Moreover, this phase also produces a simulation trapdoor that can simulate proofs.

To elaborate further, assume $m \in \mathbb{N}$ is an integer that serves as the upper bound for constraint systems in this trusted setup. Let ${\mathbb{G}_1, \mathbb{G}_2, e(\cdot,\cdot), g_1, g_2, \mathbb{F}_r, H, k_1,k_2}$ be a set of Plonk parameters.

The setup phase begins by sampling a random invertible element $\tau$ from the scalar field $\mathbb{F}_r$ of the protocol, and then outputs the simulation trapdoor $\mathbf{\Tau}$:
\begin{equation}
\label{def:groth16-trapdoor}
\Tau = (\tau)
\end{equation}
Furthermore, during the universal setup phase, this random element is combined with the generator $g_1$ of the group $\G_1$ to compute a Universal Common Reference String for any problem of upper bound $m$:
\begin{equation}
\label{def:plonk-ucrs}
UCRS(m) = \left\{g_1, g_1^{\tau}, g_1^{\tau^2},\ldots, g_1^{\tau^{m+5}}\right\}
\end{equation}
Note that Universal Common Reference Strings are not unique to a specific problem since they depend on the simulation trapdoor. A Plonk Constraint System may have more than one Universal Common Reference String. The size of a Universal Common Reference String scales linearly with the upper bound on the number of gate and public input constraints in the circuit.

If a simulation trapdoor $\Tau = (\tau)$ is provided, then $\tau$ is referred to as a \term{secret evaluation point} in the protocol. This is because a key property of any \concept{Universal Common Reference String} is that it enables the evaluation of any polynomial $P\in \F_r[x]$ of degree $deg(P)<m+5$ at the point $\tau$ in the exponent of the generator $g_1$, without revealing the actual value of $\tau$.

To be more precise, suppose that $\tau$ is the secret evaluation point and let $P(x)=a_0\cdot x^0 + a_1\cdot x^1 + \ldots a_k\cdot x^k$ be a polynomial of degree $k<m+5$ with coefficients in $\F_r$. Then we can compute $g_1^{P(\tau)}$ without disclosing the value of $\tau$:
\begin{align}
\label{eq:exp_evaluation-poly-plonk}
g_1^{P(\tau)} & = g_1^{a_0\cdot \tau^0 + a_1\cdot \tau^1 + \ldots a_k\cdot \tau^k} \notag\\
 & = g_1^{a_0\cdot \tau^0} \cdot g_1^{a_1\cdot \tau^1} \cdot \ldots \cdot g_1^{a_k\cdot \tau^k}\notag\\
 & = \Big(g_1^{\tau^0}\Big)^{a_0} \cdot \Big(g_1^{\tau^1}\Big)^{a_1} \cdot \ldots \cdot \Big(g_1^{\tau^k}\Big)^{a_k}
\end{align}
In this expression, all group points $g_1^{\tau^j}$ are part of the \concept{Universal Common Reference String}, hence, they can be used to compute the result.

Referring to the elements $g_{1}^{\tau^0}$, $g_{1}^{\tau^1}$, $\ldots$, $g_{1}^{\tau^k}$ as the \term{powers of tau} is a common practice. It is also common to call the simulation trapdoor the \term{toxic waste} of the universal setup phase. As outlined in section XXX, the simulation trapdoor can be used to generate fraud proofs, which are verifiable zk-SNARKs constructed without any knowledge of a witness.

To ensure the protocol's security, the universal setup phase must be carried out carefully, including the proper disposal of the simulation trapdoor. A trusted third party is a simple method for accomplishing this, where the party generates the \concept{Universal Common Reference String} and securely disposes of the toxic waste $\Tau$. However, finding a trusted third party can be a challenging task, and therefore, alternative methods have been developed in practical applications. These methods utilize multi-party computation in the setup phase, which can be publicly verified for proper execution. The simulation trapdoor is not recoverable if at least one participant destroys their contribution. Each participant only holds a fraction of the trapdoor, making it recoverable only if all participants collaborate and share their parts.

\begin{example}[The $3$-factorization Problem]
\label{ex:3-fac-UCRS}
To see how the universal setup phase of a Plonk zk-SNARK can be computed, consider the $3$-factorization problem from \ref{ex:3-factorization} and the Plonk parameters from \examplename{} \ref{ex:3-fac-plonk-params}. 

As we know from XXX our $3$-factorization problem has one instance constraint and $3$ gate constraints. This implies that every universal trusted setup for an upper bound greater then $4$ would be applicable to this problem. However since our pairing friendly group $\G_1$ consists of $13$ elements only, we have to choose $m$, such that $m+5<13$. 

We choose $m=5$ in order to, the same time, stay below the capacity of $\G_1$ and to show how Plonk handles upper bounds that are larger then the actual number of constraints in the system.

To transform the upper bound into a \concept{Universal Common Reference String}, we choose the  field element $\tau=2$ from $\mathbb{F}_{13}$. In real-world applications, it is important to sample this value randomly from the scalar field. Our simulation trapdoor is then given as follows:
$$
\Tau = (2)
$$
We keep the simulation trapdoor secret in order to simulate proofs later on, but we are careful to hide $\Tau$ from anyone who hasn't read this book. Then we instantiate the \concept{Universal Common Reference String} \ref{def:plonk-ucrs} from this value, by computing the powers of tau on the generator $g_1$. Since $\G_1$ is a subgroup of the \texttt{BLS6\_6} elliptic curve, we use scalar product notation instead of exponentiation (See XXX). 

We use the logarithmic order of the group $\G_1$ \ref{BLS6-G1-log}, the generator $g_1=(13,15)$, as well as the simulation trapdoor $\Tau =(2)$ and get the following:
\begin{multline*}
UCRS(5) =\{(13,15), [2](13,15), [2^2](13,15), [2^3](13,15), [2^4](13,15), \\
[2^5](13,15), [2^6](13,15), [2^7](13,15), [2^8](13,15), [2^9](13,15), [2^{10}](13,15)\}
\end{multline*}
\begin{multline*}
UCRS(5) =\{(13,15), [2](13,15), [4](13,15), [8](13,15), [3](13,15), \\
[6](13,15), [12](13,15), [11](13,15), [9](13,15), [5](13,15), [10](13,15)\}
\end{multline*}
\begin{multline*}
UCRS(5) =\{(13,15), (33,34), (35,28), (26,9), (38,15), \\
(27,34), (13,28), (33,9), (35,15), (26,34), (38,28)\}
\end{multline*}

Assuming that we have eliminated the simulation trapdoor, let's explore how the \concept{Universal Common Reference String} can aid in evaluating polynomials at the secret evaluation point within the generator exponent. Without the simulation trapdoor, and provided that our group is DL-secure XX, we no longer have access to the secret evaluation point. As a result, we are unable to evaluate polynomials at that point. Nonetheless, we can still evaluate polynomials with a degree less than $m+5$ within the exponent of the generator at that point.

To illustrate this, let's examine the Lagrange base polynomials $L_0$, $L_1$, $L_2$, and $L_3$ from XXX. To evaluate these polynomials within the exponent of $g_1$ at the secret point $\tau$ (which, in our case, is $2$) without knowledge of the value of $\tau$, we may use the \concept{Universal Common Reference String} in combination with equation XXX. If we employ scalar product notation XXX instead of exponentiation, we obtain the following:
\begin{align*}
[L_1(\tau)]g_1 & = [11\tau^3 +3\tau^2 +2\tau + 10] g_1 \\
               & = [11]([\tau^3]g_1) +[3]([\tau^2]g_1) +[2]([\tau]g_1) + [10]([\tau^0] g_1) \\
[L_2(\tau)]g_1 & = [3\tau^3 +10\tau^2+ 3\tau + 10] g_1 \\
               & = [3]([\tau^3]g_1) + [10]([\tau^2]g_1) + [3]([\tau]g_1) + [10]([\tau^0]g_1) \\
[L_3(\tau)]g_1 & = [2\tau^3 + 3\tau^2 +11\tau +10 ] g_1 \\
               & = [2]([\tau^3]g_1) + [3]([\tau^2]g_1) +[11]([\tau]g_1) +[10]([\tau^0]g_1)\\
[L_4(\tau)]g_1 & = [10\tau^3 + 10 \tau^2 +10\tau + 10] g_1 \\
               & = [10]([\tau^3]g_1) + [10]([\tau^2]g_1) + [10]([\tau]g_1) + [10]([\tau^0] g_1)
\end{align*}
In these expressions the terms $[\tau^0]g_1$, $[\tau]g_1$, $[\tau^2]g_1$ and $[\tau^3]g_1$ are elements from the UCRS, so we can substitute them and get the following results
\begin{align*}
[L_1(\tau)]g_1 & = [11](26,9) +[3](35,28) +[2](33,34) + [10](13,15)\\
[L_2(\tau)]g_1 & = [3](26,9) + [10](35,28) + [3](33,34) + [10](13,15)\\
[L_3(\tau)]g_1 & = [2](26,9) + [3](35,28) +[11](33,34) +[10](13,15)\\
[L_4(\tau)]g_1 & = [10](26,9)+[10](35,28)+[10](33,34) + [10](13,15)
\end{align*}
Subsequently, a real world application may compute these expressions using the elliptic curve scalar multiplication law. During our calculation however, we can accelerate the process by utilizing the logarithmic order XXX of $\G_1$. This approach allows us to regain access to the secret point $\tau=2$. However, we can only execute this strategy since we know the logarithmic order of $\G_1$, which is infeasible in cryptographically secure curves. The result is as follows:
\begin{align*}
[L_1(\tau)]g_1 & = [11][8](13,15) +[3][4](13,15) +[2][2](13,15) + [10](13,15) \\
               & = [11*8+3*4+2*2+10](13,15) = [10](13,15) \\
               & = (38,28)\\
[L_2(\tau)]g_1 & = [3][8](13,15) + [10][4](13,15) + [3][2](13,15) + [10](13,15) \\
               & = [3*8+10*4+3*2+10](13,15) = [2](13,15) \\
               & = (33,34)\\
[L_3(\tau)]g_1 & = [2][8](13,15) + [3][4](13,15) +[11][2](13,15) +[10](13,15)\\
               & = [2*8+3*4+11*2+10](13,15) = [8](13,15)\\
               & = (26,9)\\
[L_4(\tau)]g_1 & = [10][8](13,15) + [10][4](13,15) + [10][2](13,15) + [10](13,15)\\
               & = [10*8 + 10*4 + 10*2 + 10](13,15) = [7] (13,15)\\
               & = (27,9)
\end{align*}
In addition we compute the $\tau$ multiples of the vanishing polynomial $Z_H$ in the exponent of $g_1$, without knowing the actual value of $\tau$ using the UCRS from XXX. only. We get 
\begin{align*}
[Z_H(\tau)]g_1 & = [\tau^4 + 12] g_1 = [\tau^4]g_1 \oplus [12]([\tau^0] g_1) \\
               & = (38,15) \oplus [12](13,15)\\
[\tau\cdot Z_H(\tau)]g_1 & = [\tau\cdot(\tau^4 + 12)] g_1 = [\tau^5 + 12\tau] g_1 =  
[\tau^5]g_1 \oplus [12]([\tau] g_1) \\
               & = (27,34) \oplus [12](33,34)          
\end{align*}
Again, the elliptic curve scalar multiplication law would be applied by real world applications to compute these expressions and we expedite the process by exploiting the logarithmic order XXX of $\G_1$:
\begin{align*}
[Z_H(\tau)]g_1 & = (38,15) \oplus [12](13,15)\\
               & = [3](13,15) \oplus [12](13,15) = [3+12](13,15)= [2](13,15)\\
               & = (33,34)\\
[\tau\cdot Z_H(\tau)]g_1 & = (27,34) \oplus [12](33,34)\\
               & = [6](13,15) \oplus [12][2](13,15) = [6+12*2](13,15)= [4](13,15)\\
               & = (35,28)              
\end{align*}
\end{example}


\subsection{Circuit Specific Setup Phase}
To generate zk-SNARKs from constructive proofs in the Plonk protocol, two preprocessing phases are required. The first phase XXX, is universal and involves  a multiparty computation, where at least one participant must be honest and delete their contribution to the toxic waste XXX. The second phase, which is specific to any given Plonk Constraint System XXX, doesn't require any trust assumptions on the executors. This phase must be executed once for every Plonk Constraint System and any appropriate Universal Common Reference String. The outcome of this phase is a set of polynomials, which is necessary for both the prover and the verifier to generate and verify the zk-SNARK.

To be more specific, let $R$ denote a Plonk Constraint System having a size of $n$, with associated language $L_R$. Furthermore, let $UCRS(m)$ be a Universal Common Reference String of size $m$ such that $n\leq m$. The Plonk Constraint System has selector constants $l_i$, $r_i$, $m_i$, $o_i$, and $c_i$ for any $1\leq i \leq m$ between $1$ and $m$ and a copy constraint permutation $\sigma$. Additionally, we have a set of Plonk parameters that are denoted by ${\G_1, \G_2, e(\cdot,\cdot), g_1, g_2, \F_r, H, \omega, k_1, k_2, L_H}$.

The second setup phase then computes the following circuit specific \term{Common Reference String}, which consists of a set of polynomials, where the polynomials $L_i$ are the Lagrange base polynomials as computed in the universal setup phase XXX.
\begin{equation}
\label{def:plonk-circuit-crs}
\begin{array}{rl}
P_{l}(x) = &\sum_{i=1}^{n} {l_i}L_i(x)\\
P_{r}(x) = &\sum_{i=1}^{n} {r_i}L_i(x)\\
P_{m}(x) = &\sum_{i=1}^{n} {m_i}L_i(x)\\
P_{o}(x) = &\sum_{i=1}^{n} {o_i}L_i(x)\\
P_{c}(x) = &\sum_{i=1}^{n} {c_i}L_i(x)\\
S_{\sigma_1}(x) =& \sum_{i=1}^{n} \sigma(i)L_i(x)\\
S_{\sigma_2}(x) =& \sum_{i=1}^{n} \sigma(n+i)L_i(x)\\
S_{\sigma_3}(x) =& \sum_{i=1}^{n} \sigma(2n+i)L_i(x)
\end{array}
\end{equation}

Verifier key;
\begin{equation}
\label{def:plonk-circuit-crs}
\begin{array}{rl}
g_1^{P_l} = &\prod_{i=1}^{n} \left(g_1^{L_i(\tau)}\right)^{l_i}\\
g_1^{P_r} = &\prod_{i=1}^{n} \left(g_1^{L_i(\tau)}\right)^{r_i}\\
g_1^{P_m} = &\prod_{i=1}^{n} \left(g_1^{L_i(\tau)}\right)^{m_i}\\
g_1^{P_o} = &\prod_{i=1}^{n} \left(g_1^{L_i(\tau)}\right)^{o_i}\\
g_1^{P_c} = = &\prod_{i=1}^{n} \left(g_1^{L_i(\tau)}\right)^{c_i}\\
g_1^{S_{\sigma_1}} = &\prod_{i=1}^{n} \left(g_1^{L_i(\tau)}\right)^{\sigma(i)}\\
g_1^{S_{\sigma_2}} = &\prod_{i=1}^{n} \left(g_1^{L_i(\tau)}\right)^{\sigma(n+i)}\\
g_1^{S_{\sigma_3}} = &\prod_{i=1}^{n} \left(g_1^{L_i(\tau)}\right)^{\sigma(2n+i)}
\end{array}
\end{equation}

Circuit specific\concept{Common Reference String}s depend on Universal Common Reference Strings and as a consequence on the simulation trapdoor, and are therefore not unique to the problem. Any language $L_r$ can have more than one \concept{Common Reference String}. The  size of a \concept{Common Reference String} is linear in the size of the constraints system. The circuit specific Common Reference String is also known as the \term{prover and verifier key pair}.

As the computation of these polynomials does not require any additions randomness besides the one that comes from the Universal Common Reference String, the second setup phase can be executed without the need of any trusted third party.

\begin{example}[The $3$-factorization Problem]
\label{ex:3-fac-CSCRS}
To see how the circuit specific setup phase of a Plonk zk-SNARK can be computed, consider the $3$-factorization problem from \ref{ex:3-factorization} the Plonk parameters from \examplename{} \ref{ex:3-fac-plonk-params} and the Universal Common Reference String from example XXX. 

As we know from XXX our $3$-factorization problem has one instance constraint and $3$ gate constraints and hence is of size $4$. This implies that every Universal Common Reference String of size $m\geq 4$ is applicable to our problem. We choose the following UCRS from example XXX:
\begin{multline*}
UCRS(5) =\{(13,15), (33,34), (35,28), (26,9), (38,15), \\
(27,34), (13,28), (33,9), (35,15), (26,34), (38,28)\}
\end{multline*}
In the next step we have to compute the polynomials from XXX. BY ASSUMTION n<=M SO ENOUGH LAGRANGE POLYPEN

We do selector polynomials
$$
\begin{array}{rl}
P_{m}(x) = & \sum_{i=1}^{n} {m_i}L_i(x)\\         
         = & m_1\cdot(11x^3 +3x^2 +2x + 10) + m_2\cdot (3x^3 +10x^2+ 3x + 10) + m_3\cdot (2x^3 + 3x^2 +11x +10) \\        
         = &  1\cdot (3x^3 +10x^2+ 3x + 10) + 1\cdot (2x^3 + 3x^2 +11x +10) +  0 \cdot (2x^3 + 3x^2 +11x +10)\\
         = & 5x^3 + x + 7
\end{array}
$$
$$
\begin{array}{rl}
P_{l}(x) = & \sum_{i=1}^{n} {l_i}L_i(x)\\         
         = & l_1\cdot(11x^3 +3x^2 +2x + 10) + l_2\cdot (3x^3 +10x^2+ 3x + 10) + l_3\cdot (2x^3 + 3x^2 +11x +10) \\            
         = & 1\cdot(11x^3 +3x^2 +2x + 10) + 0\cdot (3x^3 +10x^2+ 3x + 10) + 0\cdot (2x^3 + 3x^2 +11x +10) \\ 
         = & 11x^3 +3x^2 +2x + 10 
\end{array}
$$
$$
\begin{array}{rl}
P_{r}(x) = & \sum_{i=1}^{n} {r_i}L_i(x)\\         
         = & r_1\cdot(11x^3 +3x^2 +2x + 10) + r_2\cdot (3x^3 +10x^2+ 3x + 10) + r_3\cdot (2x^3 + 3x^2 +11x +10) \\ 
         = & 0\cdot(11x^3 +3x^2 +2x + 10) + 0\cdot (3x^3 +10x^2+ 3x + 10) + 0\cdot (2x^3 + 3x^2 +11x +10) \\          
         = & 0          
\end{array}
$$
$$
\begin{array}{rl}
P_{o}(x) = & \sum_{i=1}^{n} {o_i}L_i(x)\\         
         = & o_1\cdot(11x^3 +3x^2 +2x + 10) + o_2\cdot (3x^3 +10x^2+ 3x + 10) + o_3\cdot (2x^3 + 3x^2 +11x +10) \\
         = & 0\cdot(11x^3 +3x^2 +2x + 10) + (-1)\cdot (3x^3 +10x^2+ 3x + 10) + (-1)\cdot (2x^3 + 3x^2 +11x +10) \\  
         = & (-3x^3 -10x^2 - 3x - 10) + (-2x^3 - 3x^2 -11x -10) \\ 
         = & 8x^3 + 12x + 6              
\end{array}
$$
$$
\begin{array}{rl}
P_{c}(x) = & \sum_{i=1}^{n} {c_i}L_i(x)\\         
         = & c_1\cdot(11x^3 +3x^2 +2x + 10) + c_2\cdot (3x^3 +10x^2+ 3x + 10) + c_3\cdot (2x^3 + 3x^2 +11x +10) \\
         = & 0\cdot(11x^3 +3x^2 +2x + 10) + 0\cdot (3x^3 +10x^2+ 3x + 10) + 0\cdot (2x^3 + 3x^2 +11x +10) \\
         = & 0          
\end{array}
$$
By design, these polynomials evaluate to the $j$-th selector constants if evaluated on the $j$-th element of $H$. For example $P_o(2)=-1$ because $o_2=-1$, or $P_l(1)=1$ because $l_1=1$ and so on. 

Since we have $\sigma = (9,2,8,4,5,6,7,3,1)$ we compute the permutation polynomials
$$
\begin{array}{rl}
S_{\sigma_1}(x) = & \sum_{i=1}^{n} \sigma(i)L_i(x) \\       
         = & \sigma(1)\cdot(11x^3 +3x^2 +2x + 10) + \sigma(2)\cdot (3x^3 +10x^2+ 3x + 10) + \sigma(3)\cdot (2x^3 + 3x^2 +11x +10) \\            
         = & 9\cdot(11x^3 +3x^2 +2x + 10) + 2\cdot (3x^3 +10x^2+ 3x + 10) + 8\cdot (2x^3 + 3x^2 +11x +10) \\           
         = & (8x^3 + x^2 + 5x + 12) + (6x^3 + 7x^2 + 6x + 7) + (3x^3 + 11x^2 + 10x + 2) \\    
         = & 4x^3 + 6x^2 + 8x + 8             
\end{array}
$$
$$
\begin{array}{rl}
S_{\sigma_2}(x) = & \sum_{i=1}^{n} \sigma(n+i)L_i(x) \\       
         = & \sigma(4)\cdot(11x^3 +3x^2 +2x + 10) + \sigma(5)\cdot (3x^3 +10x^2+ 3x + 10) + \sigma(6)\cdot (2x^3 + 3x^2 +11x +10) \\ 
         = & 4\cdot(11x^3 +3x^2 +2x + 10) + 5\cdot (3x^3 +10x^2+ 3x + 10) + 6\cdot (2x^3 + 3x^2 +11x +10) \\ 
         = &  (5x^3 + 12x^2 + 8x + 1) + (2x^3 + 11x^2 + 2x + 11) + (12x^3 + 5x^2 + x + 8) \\
         = & 6x^3 + 2x^2 + 11x + 7
\end{array}
$$
$$
\begin{array}{rl}
S_{\sigma_3}(x) = & \sum_{i=1}^{n} \sigma(2n+i)L_i(x) \\       
         = & \sigma(7)\cdot(11x^3 +3x^2 +2x + 10) + \sigma(8)\cdot (3x^3 +10x^2+ 3x + 10) + \sigma(9)\cdot (2x^3 + 3x^2 +11x +10) \\ 
         = & 7\cdot(11x^3 +3x^2 +2x + 10) + 3\cdot (3x^3 +10x^2+ 3x + 10) + 1\cdot (2x^3 + 3x^2 +11x +10) \\  
         = & (12x^3 + 8x^2 + x + 5) + (9x^3 + 4x^2 + 9x + 4) + (2x^3 + 3x^2 + 11x + 10)\\
         = & 10x^3 + 2x^2 + 8x + 6
\end{array}
$$
By design, the first permutation polynomial evaluates to $\sigma(j)$ if evaluated on the $j$-th element of $H$ for $j<n$. For example $S_{\sigma_1}(1)=9$ because $\sigma(1)=9$, or $S_{\sigma_1}(3)=8$ because $\sigma(3)=8$ and so on. Similar the second permutation polynomial evaluates to $\sigma(3+j)$ if evaluated on the $j$-th element of $H$ for $j<n$. For example $S_{\sigma_2}(1)=4$ because $\sigma(4)=9$, or $S_{\sigma_2}(2)=5$ because $\sigma(5)=8$ . The same pattern holds true for the third permutation polynomial.


Those polynomial can then be stored in a public place, like a blockchain, and they can be publicly verified.
\end{example}

\subsection{Prover Phase}
The goal of the prover phase is to demonstrate to any verifier that they possess knowledge of a witness $W$ for the instance $I=<I_1,\ldots, I_n>$ that satisfies the language $L_R$ of the Plonk Constraint System $R$, without disclosing any information about $W$.

To accomplish this in the Plonk protocol, we assume that the prover has access to the Plonk Constraint System of the problem, as well as an algorithm to generate constructive proofs for the Plonk Constraint System. Additionally, the prover can use a circuit-specific Common Reference String and its corresponding Universal Common Reference String.

To generate a zk-SNARK for the given instance, the prover starts by computing a valid constructive proof using the method described in TODO. This involves creating a suitable witness $W=<W_{1},\ldots,W_{3m}>$ such that $(<I_1,\ldots, I_n>; <W_{1},\ldots,W_{3m}>)$ is a valid solution to the Plonk Constraint System $R$.

Plonk's zk-SNARK, is derived from a 5-move interactive argument of knowledge, utilizing the Fiat Shamir Heuristic as explained in XXX. In order to explain the prover algorithm, we will use the structure of the 5-move protocol:

\subsubsection{Round 1}: In \term{round 1}, the prover computes the 'wire polynomials $A,B,C\in \F_r[x]$, which, loosely speaking, encode the left inputs, right inputs and outputs of addition and multiplication gates. To do so, the prover first generates blinding factors, by sampling $6$ random field elements $b_1, \ldots, b_6 \in F_r$ from the underlying field of the PlCS. Using those blinding factors, the witness $W$ XXX, the vanishing polynomial XXX, and the Lagrange base XXX of the problem, they then compute the following polynomials:
\begin{equation}
\begin{array}{rl}
A(X) =& (b_1X + b_2)Z_H(X) + \sum_{i=1}^n w_i\cdot L_i(X)\\
B(X) =& (b_3X + b_4)ZH(X) + \sum_{i=1}^n w_{n+i}\cdot L_i(X)\\
C(X) =& (b_5X + b_6)ZH(X) + \sum_{i=1}^n w_{2n+i}\cdot L_i(X)
\end{array}
\end{equation}
These polynomials are of degree $\leq n$ and the prover can use the Universal Common Reference String $UCRS(m)$ of the problem, to evaluate those polynomials in the exponent of the generator $g_1$ at the secret evaluation point $\tau$ as explained in XXX. To be more precise the prover computes the following set of elements in $\G_1$: 

TODO: In CRS and examples $g_1^{Z_H(\tau)}$ and $g_1^{\tau\cdot Z_H(\tau)}$.

\begin{equation}
\begin{array}{rl}
g_1^A = & g_1^{A(\tau)} = \left(g_1^{\tau\cdot Z_H(\tau)}\right)^{b_1}\cdot\left(g_1^{Z_H(\tau)}\right)^{b_2}\cdot \left(g_1^{L_1(\tau)}\right)^{w_1}\cdot\ldots\cdot \left(g_1^{L_n(\tau)}\right)^{w_n}\\
g_1^B = & g_1^{B(\tau)} = \left(g_1^{\tau\cdot Z_H(\tau)}\right)^{b_3}\cdot\left(g_1^{Z_H(\tau)}\right)^{b_4}\cdot \left(g_1^{L_1(\tau)}\right)^{w_{n+1}}\cdot\ldots\cdot \left(g_1^{L_n(\tau)}\right)^{w_{2n}}\\
g_1^C = & g_1^{C(\tau)} = \left(g_1^{\tau\cdot Z_H(\tau)}\right)^{b_5}\cdot\left(g_1^{Z_H(\tau)}\right)^{b_6}\cdot \left(g_1^{L_1(\tau)}\right)^{w_{2n+1}}\cdot\ldots\cdot \left(g_1^{L_n(\tau)}\right)^{w_{3n}}
\end{array}
\end{equation}
The interactive protocol would then send $m_1=(g_1^A, g_1^B, g_1^C)$ as the first move to the verifier. However since Plonk uses the Fiat Shamir Heuristic to generate a zk-SNARK, $(g_1^A, g_1^B, g_1^C)$ is considered as a virtual message only, and hence must be considered as the input to the first transcript.

TODO: DEFINE THE TRANSCRIPT AS A FAMILY OF PSEUDO RANDOM FUNCTIONS AND MAKE SENSE OF SOMETHING LIKE PRF(TRANSCRIPT(x1,x2,x3))
\begin{example}[3-fac]

\end{example}


\subsubsection{Round 2}
In \term{round 2}, the prover computes the 'permutation polynomial $Z\in \F_r[x]$ (not to be confused with the vanishing polynomial $Z_H$ as defined in XXX), which, loosely speaking, encode the equality constraints of a given PlCS. To do so, the prover computes the virtual verifier response XXX from the virtual message of round $1$. Since the verifier is required to respond with two field elements in the non-interactive protocol, the prover needs to generate two different challenges from the first transcript $T_1$: 
\begin{equation}
\beta=PRF(T_1 || 0), \gamma=PRF(T_1 || 1)
\end{equation}
Using those challenges, the blinding factors, the witness $W$ XXX, the vanishing polynomial XXX, and the Lagrange base XXX of the problem, they then compute the following field elements TODO:DESCRIPTIVE-NAME:. Using the description $H=\{\omega,\omega^2, \ldots, \omega^n\}$ of the $n$-th power roots of unity group $H$ in terms of a primitive $n$-th power root of unity $\omega$ as explained in XXX, we have
\begin{equation}
\begin{array}{rll}
c_1 = & 1\\
c_{i+1} = & \prod_{j=1}^i \frac{(w_j+\beta\omega^j+\gamma)(w_{n+j}+\beta k_1\omega^jj+\gamma)(w_{2n+j}+\beta k_2\omega^j+\gamma)}{(w_j+\sigma(j)\beta+\gamma)(w_{n+j}+\sigma(n+j)\beta+\gamma)(w_{2n+j}+\sigma(2n+j)\beta+\gamma)} & 1\leq i <n
\end{array}
\end{equation}
With the permutation coefficients at hand, the prover generates blinding factors, by sampling $3$ random field elements $b_7$, $b_8$, and $b_9$ from the underlying field of the PlCS $F_r$ and then compute the permutation polynomial as follows:
\begin{equation}
\begin{array}{rl}
Z(x) = & (b_7x^2+b_8x+b_9)Z_H(x)+\sum_{i=1}^{n} c_i\cdot L_{i}(x)
\end{array}
\end{equation}
The permutation polynomial is of degree $\leq n$ and the prover can use the Universal Common Reference String $UCRS(m)$ of the problem, to evaluate it in the exponent of the generator $g_1$ at the secret evaluation point $\tau$ as explained in XXX. To be more precise the prover computes the following element in $\G_1$: 

TODO: $g_1^{\tau^2\cdot Z_H(\tau)}$.

\begin{equation}
\begin{array}{rl}
g_1^Z = & g_1^{z(\tau)} = \left(g_1^{\tau^2\cdot Z_H(\tau)}\right)^{b_7}\cdot
\left(g_1^{\tau\cdot Z_H(\tau)}\right)^{b_8}\cdot\left(g_1^{Z_H(\tau)}\right)^{b_9}\cdot \left(g_1^{L_1(\tau)}\right)^{c_1}\cdot\ldots\cdot \left(g_1^{L_n(\tau)}\right)^{c_n}
\end{array}
\end{equation}
The interactive protocol would then send $m_2=(g_1^Z)$ as the second move to the verifier. However since Plonk uses the Fiat Shamir Heuristic to generate a zk-SNARK, $(g_1^z)$ is considered as a virtual message only, and hence must be considered as the input to the second transcript.

In \term{round 3}, the prover computes the 'quotient polynomial $t\in \F_r[x]$, which, loosly speaking, encode the equality constraints of a given PlCS. Given instance $\langle I_1,\ldots I_n\rangle$ the prover first computes the instance polynomial $PI\in \F_[r]$ as follows

TODO: THE $n$ is wrong here. It collides with the order of $H$.

\begin{equation}
PI(x) = \textstyle \sum_{i=1}^n I_i\cdot L_i(x)
\end{equation}
The prover then computes the virtual verifier response XXX from the virtual message of round $1$ and hence from the second transcript $T_2$: 
\begin{equation}
\alpha=PRF(T_2)
\end{equation}
The prover then computes the following polynomials
\begin{equation}
\begin{array}{rl}
T_1(x) = & \left(A(x)P_l(x) + B(x)P_r(x) +A(x)B(x)P_m(x) + C(x)P_o(x) + PI(x) + P_c(x)\right)
\end{array}
\end{equation}
As explained in XXX, $T_1$ is divisible by $Z_H$ if and only if $W$ is a witness to the PlCS. 
\begin{equation}
\begin{array}{rl}
T_2(x) = & \alpha\left((A(x) + \beta x + \gamma)(B(x) + \beta k_1 x + \gamma)(C(x) + \beta k_2 x + \gamma\right)\cdot Z(x)
\end{array}
\end{equation}
\begin{equation}
\begin{array}{rl}
T_3(x) = & \alpha\left((A(x) + \beta S_{\sigma_1}(x) + \gamma)(B(x) + \beta S_{\sigma_2}(x) + \gamma)(C(x) + \beta S_{\sigma_3}(x) + \gamma\right)\cdot Z(x\cdot\omega) 
\end{array}
\end{equation}
\begin{equation}
\begin{array}{rl}
T_4(x) = &  \alpha^2(Z(x) - 1)L_1(X)
\end{array}
\end{equation}
Since the polynomials $T_1$, $T_2$, $T_3$ and $T_4$ are all divisible by the vanishing polynomial $Z_H$, providing that the witness $W$ is indeed a a solution to the Plonk Constraint System $R$, the following expression is a polynomial if and only if $W$ is a solution to $R$:
\begin{equation}
T(x) = \left( T_1(x) + T_2(x) - T_3(x) + T_4(x)\right)\cdot \frac{1}{Z_H(x)}
\end{equation}
The polynomial $T$ is of degree $\leq ?$ and hence it is possible to compute three polynomials $T'_{lo}(x)$, $T'_{mid}(x)$ and $T'_{hi}(x)$, such that the degree of $T'_{lo}$ and $T'_{mid}$ are smaller then $n$ and the degree of $T'_{hi}$ is at most $n+5$ and such that the following equation holds:
\begin{equation}
T(x) = T'_{lo}(x) + x^n T'_{mid}(X) + x^{2n} T'_{hi}(x)
\end{equation}
The prover generates blinding factors, by sampling $2$ random field elements $b_{10}$, and $b_{11}$ from the underlying field of the PlCS $F_r$ and then computes:
\begin{equation}
\begin{array}{rl}
T^{lo}(x)  = & b_{10} x^n + T'_{lo}(x) \\
T^{mid}(x) = & - b_{10} + b_{11} x^n +T'_{mid}(x) \\
T^{hi}(x)  = & - b_{11} + T'_{hi}(x)
\end{array}
\end{equation}
The split quotient polynomials are all of degree $\leq n+5$ and the prover can use the Universal Common Reference String $UCRS(m)$ of the problem, to evaluate them in the exponent of the generator $g_1$ at the secret evaluation point $\tau$ as explained in XXX. To be more precise the prover computes the following element in $\G_1$: 
\begin{equation}
\begin{array}{rl}
g_1^{T_{lo}} = & g_1^{T_{lo}(\tau)} = \left(g_1^{\tau^n}\right)^{b_{10}}\cdot
\left(g_1^{\tau^{n-1}}\right)^{T^{lo}_{n-1}}\cdot\ldots\cdot \left(g_1^{\tau}\right)^{T^{lo}_{1}}\cdot \left(g_1\right)^{T^{lo}_{0}}\\
g_1^{T_{mid}} = & g_1^{T_{mid}(\tau)} = \left(g_1^{\tau^n}\right)^{b_{11}}\cdot
\left(g_1^{\tau^{n-1}}\right)^{T^{mid}_{n-1}}\cdot\ldots\cdot \left(g_1^{\tau}\right)^{T^{mid}_{1}}\cdot \left(g_1\right)^{(T^{mid}_{0}-b_{10})}\\
g_1^{T_{hi}} = & g_1^{T_{hi}(\tau)} =
\left(g_1^{\tau^{n+5}}\right)^{T^{hi}_{n+1}}\cdot\ldots\cdot \left(g_1^{\tau}\right)^{T^{hi}_{1}}\cdot \left(g_1\right)^{(T^{hi}_{0}-b_{11})}
\end{array}
\end{equation}
The interactive protocol would then send $m_3=(g_1^{T_{lo}}, g_1^{T_{mid}}, g_1^{T_{hi}})$ as the third move to the verifier. However since Plonk uses the Fiat Shamir Heuristic to generate a zk-SNARK, $(g_1^{T_{lo}}, g_1^{T_{mid}}, g_1^{T_{hi}})$ is considered as a virtual message only, and hence must be considered as the input to the third transcript.

In \term{round 4}, the prover computes an evaluation point for the wire polynomials as well as the permutation polynomial. It also evaluates the ??? polynomials at the evaluation challenge  
\begin{equation}
z=PRF(T_3)
\end{equation}
\begin{equation}
\begin{array}{lll}
\bar{a}=A(z), & \bar{b}=B(z), & \bar{c}=C(z), \\ 
\bar{s}_{\sigma_1}=S_{\sigma_1}(z), & \bar{s}_{\sigma_2}=S_{\sigma_2}(z), &\bar{z}_{\omega}=Z(z{\omega})
\end{array}
\end{equation}
The interactive protocol would then send $m_4=(\bar{a}, \bar{b}, \bar{c}, \bar{s}_{\sigma_1},
\bar{s}_{\sigma_2}, \bar{z}_{\omega})$ as the fourth move to the verifier. However since Plonk uses the Fiat Shamir Heuristic to generate a zk-SNARK, $(\bar{a}, \bar{b}, \bar{c}, \bar{s}_{\sigma_1},\bar{s}_{\sigma_2}, \bar{z}_{\omega})$ is considered as a virtual message only, and hence must be considered as the input to the fourth transcript.

In \term{round 5}, the prover computes the linearization polynomial  $W\in \F_r[x]$, which, loosely speaking, does something.
\begin{equation}
PI(x) = \textstyle \sum_{i=1}^n I_i\cdot L_i(x)
\end{equation}
The prover then computes the virtual verifier response XXX from the virtual message of round $1$ and hence from the second transcript $T_2$: 
\begin{equation}
\alpha=PRF(T_2)
\end{equation}
Assuming that $PI(z)$ is the evaluation of the instance polynomial $PI$ at the evaluation challange $z$, the prover then computes the following polynomials
\begin{equation}
\begin{array}{rl}
R_1(x) = & \left(\bar{a} \cdot P_l(x) + \bar{b} \cdot P_r(x) + \bar{a}\bar{b} \cdot P_m(x) + \bar{c} \cdot P_o(x) + PI(z) + P_c(x)\right)
\end{array}
\end{equation}

SHOW FOR EACH OF THE $R_i$' why it is divisible by $\frac{1}{x-z}$.

As explained in XXX, $T_1$ is divisible by $Z_H$ if and only if $W$ is a witness to the PlCS. 
\begin{equation}
\begin{array}{rl}
T_2(x) = & \alpha\left((\bar{a} + \beta z + \gamma)(\bar{b} + \beta k_1 z + \gamma)(\bar{c} + \beta k_2 z + \gamma)\right)\cdot Z(x)
\end{array}
\end{equation}

QUESTION TO THE AUTHORS: WHY ARE THE $\bar{s}_{\sigma_1}$'s PART OF THE TRANSCRIPT OF THE PREVIOUS ROUND BUT $PI(Z)$ IS NOT?

\begin{equation}
\begin{array}{rl}
T_3(x) = & \alpha\left(\bar{a} + \beta \bar{s}_{\sigma_1} + \gamma)(\bar{b} + \beta \bar{s}_{\sigma_2} + \gamma)(\bar{c} + \beta \cdot S_{\sigma_3(X)} + \gamma)\right)\bar{z}_\omega
\end{array}
\end{equation}
\begin{equation}
\begin{array}{rl}
T_4(x) = &  \alpha^2 (Z(X) - 1)L_1(z)
\end{array}
\end{equation}
\begin{equation}
\begin{array}{rl}
T_5(x) = & Z_H(z) \cdot \left(t_{lo}(x) + z^n t_{tmid}(x) + z^{2n} \cdot t_{hi}(x)\right)
\end{array}
\end{equation}

The prover then computes the opening challenge 
\begin{equation}
v=PRF(T_4)
\end{equation}
Compute the opening proof polynomial
\begin{multline}
W'_z(x) = R_1(x) + R_2(x) - R_3(x) + R_4(x)-R_5(x) + v(A(x) - \bar{a}) + \\
v^2(B(x) - \bar{b}) + v^3(C(x) - \bar{c}) + v^4(S_{\sigma_1}(x) - \bar{s}_{\sigma_1})
+ v^5(S_{\sigma_2}(x) - \bar{s}_{\sigma_2})
\end{multline}
Since everything is divisible by $(x-z)$, the following polynomial division is guaranteed to give a polynomial:
\begin{equation}
W_z(x) = \frac{W'_z(x)}{x-z}
\end{equation} 
Compute opening proof polynomial.
\begin{equation}
W_{z\omega}(x) = \frac{Z(x) - \bar{z}_\omega}{x - z\omega}
\end{equation}
Both opening proof polynomials are of degree $\leq ?$ and the prover can use the Universal Common Reference String $UCRS(m)$ of the problem, to evaluate these polynomials in the exponent of the generator $g_1$ at the secret evaluation point $\tau$ as explained in XXX. To be more precise the prover computes the following element in $\G_1$: 
\begin{equation}
\begin{array}{rl}
g_1^{W_z} = & g_1^{W_z(\tau)} = \left(g_1^{\tau^{?}}\right)^{(W_z)_{?}}\cdot\ldots\cdot \left(g_1^{\tau}\right)^{(W_z)_{1}}\cdot \left(g_1\right)^{(W_z)_{0}}\\
g_1^{W_{z\omega}} = & g_1^{W_{z\omega}(\tau)} = \left(g_1^{\tau^{?}}\right)^{(W_{z\omega})_{?}}\cdot\ldots\cdot \left(g_1^{\tau}\right)^{(W_{z\omega})_{1}}\cdot \left(g_1\right)^{(W_{z\omega})_{0}}\\
\end{array}
\end{equation}
The interactive protocol would then send $m_5=(g_1^{W_{z}}, g_1^{W_{z\omega}})$ as the fifth move to the verifier. However since Plonk uses the Fiat Shamir Heuristic to generate a zk-SNARK, $(g_1^{W_{z}}, g_1^{W_{z\omega}})$ is considered as a virtual message only.

Finally the prover sends the following zk-SNARK to the verifier:

\begin{equation}
\pi = \left(
\begin{array}{l}
g_1^A, g_1^B, g_1^C, g_1^Z, g_1^{T_{lo}},g_1^{T_{mid}}, g_1^{T_{hi}}, g_1^{W_z}, g_1^{W_{z\omega}}, \\
\bar{a}, \bar{b}, \bar{c}, \bar{s}_{\sigma_1}, \bar{s}_{\sigma_2}, \bar{z}_{\omega}
\end{array}
\right)
\end{equation}

QUESTION TO THE AUTHORS: WHY IS U DERIVED FROM THE TRANSCRIPT A LA FIAT SHAMIR? IT SEEMS THE VERIFIER CAN SIMPLY CHOOSE ANY U INDEPENDENT OF EVERYTHING ELSE.

\subsection{Verification Phase}
The objective of the verification phase in a Plonk zk-SNARK, given a Plonk Constraint System $R$, an instance $I = <I_1, \ldots, I_n>$, and a zk-SNARK $\pi$ (as defined in XXX), is to confirm that $\pi$ constitutes a valid proof. If the simulation trapdoor is no longer present and the proof passes the verification checks, the verifier can be convinced that there exists a witness $W = <W_1, \ldots, W_{3k}>$ such that $(I;W)$ is a word in the language of $R$. 

To achieve this in the Plonk protocol, we assume that any verifier is able to compute the pairing map $e(\cdot,\cdot)$ efficiently, has access to the \concept{Verifier key} and to the zk-SNARK $\pi$. In order to verify $\pi$ with respect to the instance $<I_1,\ldots, I_n>$, the verifier computes executes the following steps:

In a first step the prover has to verify that the zk-SNARK has the proper type. In order to do so the verifier needs to check that the data points $g_1^A$, $g_1^B$, $g_1^C$, $g_1^Z$, $g_1^{T_{lo}}$, $g_1^{T_{mid}}$, $g_1^{T_{hi}}$, $g_1^{W_z}$, $g_1^{W_{z\omega}}$ are all elements from the group $\G_1$ and that the data points $\bar{a}$, $\bar{b}$, $\bar{c}$, $\bar{s}_{\sigma_1}$, $\bar{s}_{\sigma_2}$, $\bar{z}_{\omega}$ are all elements from the scalar field $\F_r$ of $\G_1$.

In the next step the verifier needs to compute the transcripts $T_0$, $T_1$, $T_2$, $T_3$, $T_4$ from the elements of $\pi$ and then compute the challenges $\beta$, $\gamma$, $\alpha$, $z$, $v$, $\in \F_r$
TODO MAKE THIS EXPLICIT

The verifier then evaluates the vanishing polynomial $Z_H$ and the first Lagrange base polynomial $L_1$ at the evaluation point challenge $z$. As explained in XXX, this can be done efficiently
\begin{equation}
\begin{array}{rl}
Z_H(z) = & z^n -1\\
L_1(z) = \frac{\omega\cdot z^n-1}{n(z-\omega)} 
\end{array}
\end{equation}
After that the public input polynomial, must be evaluated at the evaluation point challenge. Since the verifier has access to the instance, they do the following computation:
\begin{equation}
PI(z) = \sum{j=1}^l I_j\cdot L_j(z)
\end{equation}
This computation is linear in the number of public inputs and hence is a limiting factor in the efficiency of the verifier algorithm. 

The verifier then SAMPLES A RANDOM FIELD ELEMENT $u\in \F_r$ (NOTE THIS IS FROM THE TRANSCRIPT IN THE PAPER, BUT THAT MAKES NO SENSE TO ME)
In order to compute the batched polynomial commitment, the verifier computes the following two field elements using STUFF:
\begin{equation}
\begin{array}{rl}
c_1 = & \left((\bar{a}+\beta z+\gamma)(\bar{b}+\beta k_1 z+\gamma)(\bar{c}+\beta k_2 z+\gamma)\alpha+L_1(z)\alpha^2+u\right)\\
c_2 = & (\bar{a}+\beta \bar{s}_{\sigma_1}+\gamma)(\bar{b}+\beta \bar{s}_{\sigma_2}+\gamma)\alpha\beta\bar{z}_\omega\\
c_3 = & v\bar{a} + v^2\bar{b} + v^3\bar{c} + v^4\bar{s}_{\sigma_1} + v^5\bar{s}_{\sigma_2} + u\bar{z}_\omega\\
r_0 = & \text{PI}(z) - \text{L1}(z)\alpha^2 - \alpha(\bar{a} + \beta\bar{s}_{\sigma_1} + \gamma)(\bar{b} + \beta\bar{s}_{\sigma_2} + \gamma)(\bar{c} + \gamma)\bar{z}_\omega
\end{array}
\end{equation} 
the verifier then computes
\begin{multline}
g_1^D = \left(g_1^{P_m}\right)^{\bar{a}\bar{b}} \cdot \left(g_1^{P_l}\right)^{\bar{a}} \cdot \left(g_1^{P_r}\right)^{\bar{b}} \cdot \left(g_1^{P_o}\right)^{\bar{c}} \cdot g_1^{P_c} \cdot \left(g_1^Z\right)^{c_1} \cdot \left(g_1^{s_{\sigma_3}}\right)^{-c_2}\\ \cdot \left(g_1^{T_{lo}}\right)^{-Z_H(z)} \cdot \left(g_1^{T_{mid}}\right)^{-z^n\cdot Z_H(z)} \cdot \left(g_1^{T_{hi}}\right)^{-z^{2n}Z_H(z)}
\end{multline}
\begin{equation}
g_1^F = g_1^D \cdot \left(g_1^A\right)^{v}\cdot \left(g_1^B\right)^{v^2}\cdot \left(g_1^C\right)^{v^3}\cdot \left(g_1^{S_{\sigma_1}}\right)^{v^4}\cdot \left(g_1^{S_{\sigma_2}}\right)^{v^5}  
\end{equation}

\begin{equation}
g_1^E = g_1^{-r_0+c_3}
\end{equation}

\begin{equation}
e(g_1^{W_z} \cdot u \cdot g_1^{W_{z\omega}},g_2^{\tau}) = 
e(\left(g_1^{W_z}\right)^z \cdot \left(g_1^{W_{z\omega}}\right)^{uz})\cdot g_1^F \cdot \left(g_1^{F}\right)^{-1}, g_2)
\end{equation}